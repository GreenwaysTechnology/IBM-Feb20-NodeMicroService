                                          Node JS
//////////////////////////////////////////////////////////////////////////////////////////////

What is Node.js?

Why Node.js?

How to start writing apps on Node.js
///////////////////////////////////////////////////////////////////////////////////////

What is Node.js?
   Node.js® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

What is V8?
  V8 is Google’s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, among others. It implements ECMAScript and WebAssembly

Java script core Features:

1.javascript programs are executed by javascript engine.

Java Script Engine Design:

-Single threaded - never allows to create application threads.

Having single thread , how we can run multiple tasks at the same time?
 -Async Programming
 -Callback Programming
 -Worker thread model.

ajax call - async java script and xml

java
  -connect database - thread
  -start socket - thread

 
Blocking and NonBlocking :

 Blocking means, if a thread is created which is blocked for some io like database,network connection.
if more blocked threads will lead , performance issue, may crash the whole server.
............................................................................................

Blocking and Server side Java(Tomcat)
......................................

Traditionally tomcat(jvm), uses multi threaded model.
Each request is treated as a single thread, each thread may do some io operation


Non Blocking:
 thread is not blocked for any request, rather which uses worker-thread model.

//////////////////////////////////////////////////////////////////////////////////////////

Node Arch idea:

 - single threaded
 - nonblocking networking application
 - async programming using libuv.
 - using javascript language.

             Node is non blocking,async,event driven io platform.
////////////////////////////////////////////////////////////////////////////////////////////

Node architecture:

JAVASCRIPT Modularity : Commonjs

Node platform apis 
  -event emitters
  -io
  -network - web
NPM

Frameworks
 -REST API
 -Micro services 
////////////////////////////////////////////////////////////////////////////////////

Node is not only runtime but we call platform.

Platform is nothing collection of many compoents


Blocking apis

Linux:

1.read



Non blocking implementation apis:

Linux:

1.select
   select is the first api introduced to perform non blocking operations 
   select has some drawabacks.

2.poll 
   poll api was introduced later in order to avoid some drawbacks in select.


3.epoll
   poll has some complexity in usage.
   epoll is small event notification and non blocking framework.
////////////////////////////////////////////////////////////////////////////////////////////
1.v8 engine
  Which is from goolgle.
  Supports all javascript language spec.
  Which was developed only for browser.
  Node creator wanted to build web,file system io,network io application.
  but there is no api available in javascript language.
  who wanted to add new apis on v8.
  V8 is written i C++.

2.Node binding c layer:
  node creator who created low level system calls to build io applications.
  written c language
 Node binding java script language which high level javascript apis 

3.libvu

 libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, but it’s also used by Luvit, Julia, pyuv, and others.
//////////////////////////////////////////////////////////////////////////////////////////////

node apps - javascript apps:
...........................

Javascript modularity:

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Modularity:
..........

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

 collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.


lets start cjs first;
......................

cjs is built in node js.
node supports cjs in built. no separate loader or linker is required
but if you run cjs code on browsers , we need loaders.
/////////////////////////////////////////////////////////////////////////////////////////////////////
Object augmentation:

In javascript objects are simple map/dictionary.

Since object is datastructure , we can add,delete,update,iterate object properties dynamically.
 This is called as "Object augmentation".
//object augmentation;

//object has no any property ; empty object
let product = {
   id:1
};
console.log(product)
//object augmentation: adding new property 
product.name = "Phone"
product.qty =100
product.price=0;
console.log(product)
//object augmentation: update new property 
//if property exits, it updates, if not , add 
product.price=100;
console.log(product)
//object augmentation: remove new property 
delete product.qty;
console.log(product)
//object augmentation ; iterate
for(let prop in product){
    console.log(prop,product[prop])
}
/////////////////////////////////////////////////////////////////////////////////////////////

COMMONJS : CJS

Code sharing among files.

What could be code?
could be variable declaration,class declaration,function declaration.

Linking files :


cjs provides some keywords

require() - function -  linking files

exports,module.exports - built in variables  : code sharing


How to link files?

src/index.js

require('./mylib')

src/mylib.js

console.log('mylib')

How to share code?
 variables,functions,class..

exports:
 -exports is built in variable.
 -exports has some default value.

require('file'): function call

 -parameter is file name
 -return value is literal object with respect to exports

let myresult = require('file')

The default value is empty literal object.
//////////////////

src/info.js

//code sharing -  exports

//exports = {}
//augment empty object pointed by exports variable
exports.message = "Hello"
exports.rank=10
exports.isActive=true;
exports.doSomething = function(){
    return "something"
}
exports.address = {
    city:'Coimbatore',
    state:'Tamil Nadu',
}
/////////////
src/index.js
// const res = require('./info')

// console.log(res)

// console.log(res.message,res.rank,res.isActive,res.doSomething())
const { message, rank, isActive, doSomething, address: { city, state } } = require('./info');

console.log(message, rank, isActive, doSomething(),city,state)
///////////////////////////////////////////////////////////////////////////////////////////

module.exports: another way of sharing code
............................................

exports vs module.exports

1.exports will export the entire as single object.
2.where as module.exports , wont export code as object, rahter which exports code as it is.

module.exports will be suitable single exports.
 -you have class
 -you have function
 -you have variable having arrays.

with require() , will not return object,rather which returns what you have returned(fun,varible,object,class).


src/GreeterService.js

class GreeterService{
    constructor(){
        console.log('Greeter service is initlaized')
    }
    //biz apis
    sayHai(){
        return 'Hai'
    }
    sayHello(){
        return 'Hello'
    }
    sayGreet(){
        return 'Greet'
    }
}

//here we pack class 
//module.exports = GreeterService;
//here we pack object
module.exports = new GreeterService();

src/index.js
// const GreeterService = require('./GreeterService')

// let service = new GreeterService();
// console.log(service.sayHai());
// console.log(service.sayGreet())

const {sayGreet,sayHai} = require('./GreeterService');
const {log} = console

log(sayHai());
log(sayGreet())
//////////////////////////////////////////////////////////////////////////////////////////////

src/mock-data/users.js
const USERS=[
    {
        id: 1,
        name: "Leanne Graham",
        username: "Bret",
        email: "Sincere@april.biz",
        address: {
            street: "Kulas Light",
            suite: "Apt. 556",
            city: "Gwenborough",
            zipcode: "92998-3874",
            geo: {
                lat: "-37.3159",
                lng: "81.1496"
            }
        },
        phone: "1-770-736-8031 x56442",
        website: "hildegard.org",
        company: {
            name: "Romaguera-Crona",
            catchPhrase: "Multi-layered client-server neural-net",
            bs: "harness real-time e-markets"
        }
    },
    {
        id: 2,
        name: "Ervin Howell",
        username: "Antonette",
        email: "Shanna@melissa.tv",
        address: {
            street: "Victor Plains",
            suite: "Suite 879",
            city: "Wisokyburgh",
            zipcode: "90566-7771",
            geo: {
                lat: "-43.9509",
                lng: "-34.4618"
            }
        },
        phone: "010-692-6593 x09125",
        website: "anastasia.net",
        company: {
            name: "Deckow-Crist",
            catchPhrase: "Proactive didactic contingency",
            bs: "synergize scalable supply-chains"
        }
    },
    {
        id: 3,
        name: "Clementine Bauch",
        username: "Samantha",
        email: "Nathan@yesenia.net",
        address: {
            street: "Douglas Extension",
            suite: "Suite 847",
            city: "McKenziehaven",
            zipcode: "59590-4157",
            geo: {
                lat: "-68.6102",
                lng: "-47.0653"
            }
        },
        phone: "1-463-123-4447",
        website: "ramiro.info",
        company: {
            name: "Romaguera-Jacobson",
            catchPhrase: "Face to face bifurcated interface",
            bs: "e-enable strategic applications"
        }
    },
    {
        id: 4,
        name: "Patricia Lebsack",
        username: "Karianne",
        email: "Julianne.OConner@kory.org",
        address: {
            street: "Hoeger Mall",
            suite: "Apt. 692",
            city: "South Elvis",
            zipcode: "53919-4257",
            geo: {
                lat: "29.4572",
                lng: "-164.2990"
            }
        },
        phone: "493-170-9623 x156",
        website: "kale.biz",
        company: {
            name: "Robel-Corkery",
            catchPhrase: "Multi-tiered zero tolerance productivity",
            bs: "transition cutting-edge web services"
        }
    },
    {
        id: 5,
        name: "Chelsey Dietrich",
        username: "Kamren",
        email: "Lucio_Hettinger@annie.ca",
        address: {
            street: "Skiles Walks",
            suite: "Suite 351",
            city: "Roscoeview",
            zipcode: "33263",
            geo: {
                lat: "-31.8129",
                lng: "62.5342"
            }
        },
        phone: "(254)954-1289",
        website: "demarco.info",
        company: {
            name: "Keebler LLC",
            catchPhrase: "User-centric fault-tolerant solution",
            bs: "revolutionize end-to-end systems"
        }
    },
    {
        id: 6,
        name: "Mrs. Dennis Schulist",
        username: "Leopoldo_Corkery",
        email: "Karley_Dach@jasper.info",
        address: {
            street: "Norberto Crossing",
            suite: "Apt. 950",
            city: "South Christy",
            zipcode: "23505-1337",
            geo: {
                lat: "-71.4197",
                lng: "71.7478"
            }
        },
        phone: "1-477-935-8478 x6430",
        website: "ola.org",
        company: {
            name: "Considine-Lockman",
            catchPhrase: "Synchronised bottom-line interface",
            bs: "e-enable innovative applications"
        }
    },
    {
        id: 7,
        name: "Kurtis Weissnat",
        username: "Elwyn.Skiles",
        email: "Telly.Hoeger@billy.biz",
        address: {
            street: "Rex Trail",
            suite: "Suite 280",
            city: "Howemouth",
            zipcode: "58804-1099",
            geo: {
                lat: "24.8918",
                lng: "21.8984"
            }
        },
        phone: "210.067.6132",
        website: "elvis.io",
        company: {
            name: "Johns Group",
            catchPhrase: "Configurable multimedia task-force",
            bs: "generate enterprise e-tailers"
        }
    },
    {
        id: 8,
        name: "Nicholas Runolfsdottir V",
        username: "Maxime_Nienow",
        email: "Sherwood@rosamond.me",
        address: {
            street: "Ellsworth Summit",
            suite: "Suite 729",
            city: "Aliyaview",
            zipcode: "45169",
            geo: {
                lat: "-14.3990",
                lng: "-120.7677"
            }
        },
        phone: "586.493.6943 x140",
        website: "jacynthe.com",
        company: {
            name: "Abernathy Group",
            catchPhrase: "Implemented secondary concept",
            bs: "e-enable extensible e-tailers"
        }
    },
    {
        id: 9,
        name: "Glenna Reichert",
        username: "Delphine",
        email: "Chaim_McDermott@dana.io",
        address: {
            street: "Dayna Park",
            suite: "Suite 449",
            city: "Bartholomebury",
            zipcode: "76495-3109",
            geo: {
                lat: "24.6463",
                lng: "-168.8889"
            }
        },
        phone: "(775)976-6794 x41206",
        website: "conrad.com",
        company: {
            name: "Yost and Sons",
            catchPhrase: "Switchable contextually-based project",
            bs: "aggregate real-time technologies"
        }
    },
    {
        id: 10,
        name: "Clementina DuBuque",
        username: "Moriah.Stanton",
        email: "Rey.Padberg@karina.biz",
        address: {
            street: "Kattie Turnpike",
            suite: "Suite 198",
            city: "Lebsackbury",
            zipcode: "31428-2261",
            geo: {
                lat: "-38.2386",
                lng: "57.2232"
            }
        },
        phone: "024-648-3804",
        website: "ambrose.net",
        company: {
            name: "Hoeger LLC",
            catchPhrase: "Centralized empowering task-force",
            bs: "target end-to-end models"
        }
    }
];

module.exports = USERS;
//////////////////////////////////////////////////////////////////////////////////////////////
src/services/UserService.js

const USERS = require('../mockdata/users-mock')

class UserService {
    constructor() {

    }
    findAll() {
        return USERS;
    }
}
module.exports = new UserService();


const {findAll} = require('./services/UserService');

console.log(findAll())
/////////////////////////////////////////////////////////////////////////////////////////////

How to async programming?

All apis are not async.

How to know async apis?

async api are provided by javascript and node platform.

callback function
 are normal functions which are called because of event notification.
 callbacks function are called by event loop(thread)
 callback functions are called when result is ready only.

callbacks are passed as parameter to another function(caller)


1.api
2.callback
3.registeration by caller.

Apis:
javascript specific apis
1.timers
  -settimeout
  -setinterval
2.ajax - network calls
3.websocket
4.dom apis
etc....

Node platform api
1.timers
2.io apis
3.networking apis
etc....


Styles of async programming:

1.callback - core style
  callbacks has some drawbacks.
2.promises
3.async await.

Demo:

1.callback based programming

//timer and style is callback.

// function delay(callback) {
//     setTimeout(callback, 1000,'I am delayed');
// }
const delay = callback => setTimeout(callback, 1000, 'I am delayed')
//passing function
console.log('start')
delay(data => console.log(data));
console.log('end')

const heartBeat = callback=>{
  const timerId= setInterval(callback,1000,new Date())
  //stop the interval
  setTimeout(()=>{
      console.log('stopping task')
      //stopping
       clearInterval(timerId);
  },5000)

}
heartBeat(now=>console.log(now))
/////////////////////////////////////////////////////////////////////////////////////////////
//callback nesting/compostion

const getUser = (resolve, reject) => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //  user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, err)
    }
};
//Login function is called with user as input.
const login = (user, resolve, reject) => {
    let status = "Login success"
    let err = "Login failed"
    //bizlogic
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, status)
    } else {
        setTimeout(reject, 1000, err)
    }
}

const showpage = (status, resolve, reject) => {
    //biz logic
    if (status === 'Login success') {
        setTimeout(resolve, 1000, { message: 'You are admin' });
    } else {
        setTimeout(reject, 1000, { message: 'You are guest' });
    }

}


getUser(user => {
    console.log('get User is called')
    login(user, status => {
        console.log('login is called')
        showpage(status, who => {
            console.log('show page is called')
            console.log(who)
        }, error => {
            console.log(error)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})

Questions:

1.Whether this is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?


  "No" : This is what we call as "Callback hell".

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming /async/non blocking ? or How to avoid callback hell?


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced promise design pattern  as  "Promise" Object  in javascript.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Promise Object:
..............
 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Promises and non blocking,async and callback hell issues:
.........................................................

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create Promise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

Lets code using Promise

Promise Object creations:

1.factory apis.
 resolve
 reject
 both


//promise object
//using factory methods
//promise replaces callback function passing


// function getSuccess(callback) {
//     //factory
//     setTimeout(callback, 0, "Success")
// }

// getSuccess(data => console.log(data));

function getSuccess() {
    //factory
    return Promise.resolve('Success')
}
function getError() {
    //factory
    return Promise.reject('something went wrong!!')
}

function validate() {
    let userName = "admin";
    let password = "admin";
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    }
    return Promise.reject('Login failed')
}


//
// let result = getSuccess();
// console.log(result)
// result.then(data=>console.log(data))
console.log('start')
getSuccess()
    .then(data => console.log(data));

getError()
    .catch(err => console.log(err));

validate()
    .then(status => console.log(status))
    .catch(err => console.log(err))
    .finally(() => console.log('done'))
console.log('end')
///////////////////////////////////////////////////////////////////////////////////
//Promise constructors pattern is used to abstract existing callback based programming.

function delay(callback) {
    //i want to return some data using timer after 5000ms
    setTimeout(callback, 5000, "Hello")
}
function delayWithPromise() {
    return new Promise((resovle, reject) => {
        setTimeout(resovle, 5000, "Hello")
    });
}

delay(data => console.log(data))

delayWithPromise()
    .then(data => console.log(data))
    .catch(err => console.log(err))
    .finally(() => console.log('done'));

//////////////////////////////////////////////////////////////////////////////////////////////

callback hell using promise 

//callback nesting/compostion

const getUser = () => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //  user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
};
//Login function is called with user as input.
const login = user => {
    let status = "Login success"
    let err = "Login failed"
    //bizlogic
    if (user.name === 'admin') {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, status)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
}

const showpage = status => {
    //biz logic
    if (status === 'Login success') {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, { message: 'You are admin' });
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, { message: 'You are guest' });
        });
    }

}

getUser()
    .then(user => {
        console.log('Get user is called', user)
        login(user)
            .then(status => {
                console.log('login is called', status);
                showpage(status)
                    .then(pageres => {
                        console.log('show page is called', pageres)
                    })
                    .catch(pageerror => console.log(pageerror));
            })
            .catch(err => {
                console.log(err)
            });
    })
    .catch(err => {
        console.log(err)
    });

//simplified way

getUser()
    .then(user => {
        console.log('Get user is called', user)
        return login(user)
    })
    .then(status => {
        console.log('login is called', status);
        return showpage(status);
    })
    .then(page => {
        console.log('show page is called', page)
    })
    .catch(err => {
        console.log(err);
    });

getUser()
    .then(user => login(user))
    .then(status => showpage(status))
    .then(page => console.log('show page is called', page))
    .catch(err => {
        console.log(err);
    });


// getUser(user => {
//     console.log('get User is called')
//     login(user, status => {
//         console.log('login is called')
//         showpage(status, who => {
//             console.log('show page is called')
//             console.log(who)
//         }, error => {
//             console.log(error)
//         })
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })


The above code has solved callback hell issues, but still has some complixty, this 
is called "Promise hell".

How to avoid promise hell?


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

async and await ; es 7 keywords


Promise Hell: Promise has limitions;
......................

1.Promise is still  complex when you start scalling complex async operations.

2.Which is not readable ,which uses lot of then, catch blocks

In order to write even simple complex async work flows ES 7 introduced
a concept called "async await" keywords


 It is simplest pattern of Promises.
 It is promise driven only.

         "Sync style of Async Code" 

async key must be used with function declaration.
await is used to pause async calls


async ;

-used in front of function declaration ; those functions are called async function.

async is keyword must be used infront of function- async functions


async function returns Promise Object ---promise.resolve


async function getValue() {
    return 100;  // return Promise.resolve(100)
}
async function getSomething() {
    return Promise.resolve('something')
}

function getUser() {
    return Promise.resolve({ id: 1, name: 'admin' })
}

console.log(getValue());
getValue()
    .then(data => console.log(data));

getSomething()
    .then(data => console.log(data));
//how to read data from promise

//async....await

async function init() {
    const user = await getUser();
    console.log(user);
}
init();



///////////////

const getUser = () => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
};
//login; login function will be only if getUser returns user data.
const login = (user) => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, { message: 'Login Success' });
        } else {
            setTimeout(reject, 1000, { message: 'login failed' });
        }
    });

}

const showpage = (status) => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (status.message === 'Login Success') {
            setTimeout(resolve, 1000, { message: 'You are admin' });
        } else {
            setTimeout(reject, 1000, { message: 'You are guest' });
        }
    });

};

async function init() {
    try {
        const user = await getUser();
        const status = await login(user);
        const page = await showpage(status);
        console.log(user,status,page)
    }
    catch (err) {
        console.log(err)
    }
}
init();
///////////////////////////////////////////////////////////////////////////////////////////


const USERS = require('../mockdata/users-mock')

class UserService {
    constructor() {

    }
    //sync
    findAll() {
        return USERS;
    }
    //async versions : callback version and promise 
    findAllCallback(callback) {
        setTimeout(callback, 5000, USERS);
    }
    findAllPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, USERS);
        });
    }

}
module.exports = new UserService();



const { findAll, findAllCallback, findAllPromise } = require('./services/UserService');


async function main() {
    //sync
    // console.log(findAll());
    //console.log('start')
    //  findAllCallback(users=>console.log(users))
    // findAllPromise()
    //     .then(users => console.log(users))
    //     .catch(err => console.log(err))
    try {
        const users = await findAllPromise();
        console.log(users);
    }
    catch (err) {
        console.log(err)
    }
    // console.log('end')

}
main();
////////////////////////////////////////////////////////////////////////////////////////////

NODE APIS:
.........

Types of modules:

1.custom module
  built by us
2.built in modules
   provided by nodes
  
3.provided by third party/community
  libs,frameworks
 
1.node in built modules


1.os module
2.events module
3.file system module
4.path
5.http module

note: any module is distributed as javascript file

OS: Operating System
....................
The os module provides operating system-related utility methods and properties. 
It can be accessed using:
  os.js  ------> const ? =  require('os')

const { arch,hostname,cpus } = require('os');

console.log('Operating system infromation')
console.log(arch())
console.log(hostname())
console.log(cpus())




./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Event Emitter module;

how to build application event driven programming.

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.
const EventEmitter = require('events');

const eventEmiter = new EventEmitter();

//Pub - sub

//register event :Listener
eventEmiter.on('hello', (data) => {
    console.log(data);
});

//Publisher : to emit event and send data

eventEmiter.emit('hello','Hello')

class OrderService extends EventEmitter {
    constructor() {
        super();
        //listener regeration ; event represents object having data .
        this.on('sales', event => {
            console.log(`Got ${event.orderId} ${event.qty} ${event.value}`)
        })
    }
    placeOrder(order) {
        //when ever place order is called, it can emit event
        setTimeout(() => {
          //async event driven programming
            this.emit('sales', order);
        }, 1000)
    }

}
//start
function startApp() {
    let orderService = new OrderService();
    //call biz api
    orderService.placeOrder({ orderId: 'OD001', qty: 100, value: 1000 })
}
startApp();

/////////////////////////////////////////////////////////////////////////////////////////////

IO
 -Fs
Network
 -web
 
npm
frameworks

/////////////////////////////////////////////////////////////////////////////////////////////

File system IO;

 - how to read file.
 - how to data into file.

node created async io,node also supports sync io like other languages.

Types io:
 -non-streaming io
 -streaming io /evented io.

Global variables in node:
.........................

__dirname
__filename



Non Streaming :

const fs = require('fs');
const path = require('path');

//const filePath = './src/assets/info.txt';
const filePath = path.join(__dirname,'assets/info.txt')
const options = {
    encoding: 'utf-8'
}
console.log('start')
fs.readFile(filePath, options, function (err, data) {
    if (err) throw err;
    console.log(data);
});
console.log('end')
////////////////////////////////////////////////////////////////////////////////////////////

Write file:
...........

const fs = require('fs');
const path = require('path');

//const filePath = './src/assets/info.txt';
const filePath = path.join(__dirname, 'assets/infocopy.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})

Non streaming mode:

 The whole is file will be loaded into node process memory first, then file will be delivered
 This is not good , when we request files in network, if more files loaded into memory
 then node process memoery will grow, it may crash.

how to read and write files in non-streaming mode.
  -readFile and wirteFile
 

Streaming:

Streaming is nothing but flow of data(chunks).
Streaming allows move the data from one place to another place one by one.
Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output

node has lot of built in stream apis

Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin


Writable Streams:

HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
 The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.


const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log(`Some thing went wrong! ${err}`)
});

////////////////////////////////////////////////////////////////////////////////////////////
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})
//////////////////////////////////////////////////////////////////////////////////////////////

Bigfile creation:
const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")
const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();
////////////////////////////////////////////////////////////////////////////////////////////

Big file read:

const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(fileName, config);

//read data ; you need to register listeners for io.

//data event is emitted by os for each chunk of data
inputStream.on('data', function (chunk) {
    log(`Received ${chunk.length} bytes of data.`)
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
})

//error event: for error handling
inputStream.on('error', (err) => {
    log(`Some thing went wrong! ${err}`)
});
////////////////////////////////////////////////////////////////////////////////////////////////

Read + Write:
.............
const fs = require('fs');
const path = require('path');

//read
const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(inputfileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});

BackPressure:
.............
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.

How to handle back pressure?

 apis  : pause,resume,drain event


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);



readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});

///////////////////////////////////////////////////////////////////////////////////////////////////

pipe method is simplest method for implementing back pressure:


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Web programming : network Programming:
......................................

Nonblocking web servers and apps.

HTTP:

Node invented for building network io applications.

Network implementation in non blocking:

HTTP module is used to build http server,app, deployment


HTTP modules objects:


1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.


Note: all http implemnetation is streaming powered by default.


Steps:

1.create Server.
2.request-response handling
3.starting server

Node handles every client request by a single thread-Event loop thread


const http = require('http');

//create server

const server =  http.createServer((req,res)=>{
    res.write('Hello');
    res.end();
});
//start the server 
server.listen(3000,()=>{
    console.log('Server is Ready!');
})

//////////////////////////////////////////////////////////////////////////////////////////


send json data:

const http = require('http');
const USERS =require('./mock-data/users-mock')


//create server

const server =  http.createServer((req,res)=>{
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    const users = JSON.stringify(USERS);
    res.write(users);
    res.end();
});
//start the server 
server.listen(3000,()=>{
    console.log('Server is Ready!');
})
///////////////////////////////////////////////////////////////////////////////////////////

client -------Web layer -----Service layer-------Mock data.

src/services/userservice.js


const http = require('http');
const { findAll } = require('./services/userservice')

//create server

const server = http.createServer(async (req, res) => {
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    // findAll().then((users)=>{
    //     res.write(users);
    //     res.end();
    // })
    try {
        const users = await findAll();
        res.write(users);
        res.end();
    }
    catch(err){
        res.write({message:'something went wrong'})
        res.end();
    }

});
//start the server 
server.listen(3000, () => {
    console.log('Server is Ready!');
})

const http = require('http');
const { findAll } = require('./services/userservice')

//create server

const server = http.createServer(async (req, res) => {
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    // findAll().then((users)=>{
    //     res.write(users);
    //     res.end();
    // })
    try {
        const users = await findAll();
        res.write(users);
        res.end();
    }
    catch(err){
        res.write({message:'something went wrong'})
        res.end();
    }

});
//start the server 
server.listen(3000, () => {
    console.log('Server is Ready!');
})
////////////////////////////////////////////////////////////////////////////////////////////

Client INput:
............


const http = require('http');
const { log } = console;

const server = http.createServer((req, res) => {

    let body='';
    req.on('data', (chunk) => {
        body += chunk;
        log(body);
    });

    res.on('close', () => {
        log('response close event is called')
    });
    res.on('finish', () => {
        log('response has been sent /committed')
    });
    res.end("Hello,Node")
});

server.listen(3000, () => {
    console.log(`Http Server listens @ ${3000}`)
});
////////////////////////////////////////////////////////////////////////////////////////////

Can you build realtime web applications using http module alone?

Yes,but it takes lot of code(boiler platecode).

We need abstractions -  libs,frameworks......

who offers frameworks and libs? from where we can get it?

Third parties,communities,companies(google,ms,yahoo,facebook....)

From centeral repo server called "npm registry"

How to bring thrid party libs/frameworks/modules into our project?

Tool : NPM - Node package Manager:
.................................
npm is tool is used to distribute node modules to others
and you can get node modules from other others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.

Java script application :

Javascript Project Structure:(server side/ client side)
.........................................................


The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.

create package.json file

>npm init

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC"
}

npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


installing module:

>npm install  moduleName  --options
>npm i moduleName --options


>npm install module 
  here no option is told, means default is --save

>npm i module

options:
 --save ; 
 --save-dev
 -g

//////////////////////////////////////////////////////////////////////////////////////////////////////
App development ; three stage

1.dev
2.testing
3.production.

if you install any packages/dependencies, you can tell that is it for production and developemnt, only devel/testing

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>java

 --save = >    development + production
 --save-dev => only for development

Which code need not be used for production:

1.All testing related  libs/frameworks - unit,e2s
2.Tools like compilers,frameworks related code.

Who will separate out this depedency(lib) for production/dev

 Build tools -  webpack.
 webpack will scan package.json---extracting prod depedencies

////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////

 --save => dev + production
 default =>dev + production

 --save-dev  -->only dev 

//////////////////////////////////////////////////////////////////////////////////////////////////////

Eg;
npm i --save lodash

package.json
{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  }
}
node_modules

const array = require('lodash/array')

const list = [1, 2, 3];

array.fill(list, 'a');
console.log(list);


/////////////////////////////////////////////////////////////////////////////////////////////////////

Development only module: unit testing module

->chai.js

npm install chai --save-dev


//////////////////////////////////////////////////////////////////////////////////////////////

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  },
  "devDependencies": {
    "chai": "^4.2.0"
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////

How to uninstall node modules?
//////////////////////////////////////////////////////////////////////////////////////////////////////

How to remove unwanted node modules?

npm uinstall jquery --save
////////////////////////////////////////////////////////////////////////////////////////////////////////

Global Modules:
...............

-g  --global:
............

global modules are modules which are not installed inside project floder.

What is use of global modules?

->tools
   like compilers,build system,webserver,testing frameworks.


C:\Users\sasub\AppData\Roaming\npm -- here only all global modules will be installed.


Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha

Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha
...........................................&&&&&&&&&&&&&&&&&&&&********************************************


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Automation:


We can automate js applications.

write all auotomation steps inside scripts

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }

key: value

key is called command-script command
value is task to be executed. ; task could be any thing.

command can be built in or custom commands

npm provides lot of built in commands

start,test,postinstall,preinstall..........


how to run node apps using npm scripts.

node filename.js --direct use

via script
how to run script

>npm commandname ---incase of built in command
>npm start

>npm run commandname - custom commands
>npm run subu

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js",
    "subu"  :"node src/app.js"
  },

npm test
npm start
npm run subu
..............................................................................................
                      Global Modules and Its problems, How to solve them
/////////////////////////////////////////////////////////////////////////////////////////////

Objective:
 For brining tools

tools
  -compilers
  -frameworks
  -webservers
  -build tools

npm install webpack -g

Problems with Global Modules:
..............................

1.version and compablity issue for new projects

solution: 
 install those golbal tools as local dev modules



solution: 
 install those golbal tools as local dev modules

g vs --save-dev:

global dependencies not good for multiple sharing projects
install tools as project specific. --save-dev

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "start": "node src/app.js",
    "subu": "node src/app.js"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^8.2.1"
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////
                              How to Build Restfull Web Apps                                     
Framework: Express.js

What is express?
Express Fast, unopinionated, minimalist web framework for Node.js

express is built on top of http core module.

What express provides?

-To build rest api facility fast using routers
->provides of lot of middlewares(utility libs) for database access,secuity,template....


How to start express project

-from begining

-using tool express-generator
  used to create quick web apps...
   

 npm install express --save


Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which other objects
  entry and exit of an application
  application is created by calling function

2.Request

4.Response

5.Router

1.Application object roll:

Routing HTTP requests; see for example, app.METHOD and app.param.
Configuring middleware; see app.route.
Rendering HTML views; see app.render.
Registering a template engine; see app.engine.

const express  = require('express');

//create application object
const app =  express();

//create End Points

app.get('/',(req,res)=>{
    res.end('Home')
});
app.get('/api/message/hai',(req,res)=>{
    res.end('hai')
});
app.get('/api/message/hello',(req,res)=>{
    res.end('hello')
});
app.get('/api/message/greet',(req,res)=>{
    res.end('greet')
});
app.post('/api/message/save',(req,res)=>{
    res.end('save')
})
app.put('/api/message/update',(req,res)=>{
    res.end('put')
})
app.delete('/api/message/delete',(req,res)=>{
    res.end('delete')
})

//start server

app.listen(3000,()=>console.log('express server is running!!!'))
/////////////////////////////////////////////////////////////////////////////////////////////

Modualirty:
...........


const express = require('express');
const { findAll } = require('../services/userservice');

//create router object
const userRouter = express.Router();

userRouter.get('/list', async (req, res) => {
    const users = await findAll();
    res.json(users)
});

module.exports = userRouter;


const express = require('express');
const { listTodos } = require('../services/todoservice');

//create router object
const todoRouter = express.Router();

todoRouter.get('/list', async (req, res) => {
    const todos = await listTodos();
    res.json(todos)
});

module.exports = todoRouter;


const TODOS = require('../mock-data/todos');

class TodoService {
    constructor() {
    }
    listTodos() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, TODOS);
        });
    }
 
}

module.exports = new TodoService();



const USERS = require('../mock-data/users-mock');

class UserService {
    constructor() {
    }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, USERS);
        });
    }
 
}

module.exports = new UserService();




const express = require('express');
const userRouter = require('./routers/userrouter');
const todoRouter = require('./routers/todorouter')

const app = express();

//Linking UserRouter with main app
app.use('/api/users',userRouter);
app.use('/api/todos',todoRouter);


app.listen(3000, () => console.log('Express server is running!!!'))

////////////////////////////////////////////////////////////////////////////////////////////

Middlewares:

 - plugins , can  be plugged


types of middlewares

1.built in middlewares
2.third party middleware
3.custom middleares.

Use case :
 How to read JSON input. Express server need to read json which was submitted by endusers

User will submit as json --- express need to convert into javascript object.

any middleware is distributed as node modules only, so you need to install



Steps for any middleware integration:
......................................

1.npm install body-parser

2.Register middleware - in the main app
const bodyParser = require('body-parser')
// parse application/json
app.use(bodyParser.json())

3.use the middleware;
////////////////////////////////////////////////////////////////////////////////////////////

Express application generator
.............................

npm install -g express-generator

create project using express-generaator

>express --view=pug myapp

/////////////////////////////////////////////////////////////////////////////////////////////

Database integration: mongodb:

Driver : mongojs






/////////////////////////////////////////////////////////////////////////////////////////////

                                 Distribted Application development
                                       (Micro services)

What is Microservice?

MicroSerivice is architecture style , to build distributed application.

Micro services is collection of many design patterns.

What is Service?
   Service represents biz problem/domain problem

Microservices design patterns:

1.domain design - decompose design pattern- domain driven design 
2.deployment 
3.communication
4.testing
5.monitoring
6.fault management
7.data mananagement
etc...

what about implementation?

 Today most of the programming language provides implemenation for building microservice
style apps.

java:jvm

1.Spring cloud project
2.Vertx


javascript:nodejs


                                   Moleculer

Progressive microservices framework for Node.js

Moleculer is framework which has implemented most of common microservices design patterns.


Moleculer features:

1.Promise-based solution (async/await compatible)
2.request-reply concept
3.support event driven architecture with balancing
4.built-in service registry & dynamic service discovery
5.load balanced requests & events (round-robin, random, cpu-usage, latency, sharding)
6.many fault tolerance features (Circuit Breaker, Bulkhead, Retry, Timeout, Fallback)
7.plugin/middleware system
8.support versioned services
9.support Streams
10.service mixins
11.built-in caching solution (Memory, MemoryLRU, Redis)
12.pluggable loggers (Console, File, Pino, Bunyan, Winston, Debug, Datadog, Log4js)
13.pluggable transporters (TCP, NATS, MQTT, Redis, NATS Streaming, Kafka, AMQP 0.9, AMQP 1.0)
14.pluggable serializers (JSON, Avro, MsgPack, Protocol Buffer, Thrift)
15.pluggable parameter validator
16.multiple services on a node/server
17.master-less architecture, all nodes are equal
18.parameter validation with fastest-validator
19.built-in metrics feature with reporters (Console, CSV, Datadog, Event, Prometheus, StatsD)
20.built-in tracing feature with exporters (Console, Datadog, Event, Jaeger, Zipkin)
21.official API gateway, Database access and many other modules…
/////////////////////////////////////////&&&&&&&&&&&&&&&&&&&&&///////////////////////////////

Moleculer setup:

project creations;

1.from begining like normal node application.
2.moleculer cli- to setup realtime project with all artifacts.

npm install moleculer


Core concepts in Molecular:
..........................

1.Service
 A service is a simple JavaScript module containing some part of a complex application. 
 A service represents a biz logic in your application.

2.Service Broker : == Spring Container
 Service Broker is the heart of Moleculer.

It is responsible for management and communication between services (local and remote). 

3.node :
 A node is a simple OS process running on a local or external network.
 A single instance of a node can host one or many services.
 node js platform - v8+libvu..

Each node must have an instance of Service Broker.

"Service Broker is one single Node instance - Node runtime"

4.Transporter
	Transporter is a communication bus that services use to exchange messages. 
 It transfers events, requests and responses.

5.Gateway
     API Gateway exposes Moleculer services to end-users.
 The gateway is a regular Moleculer service running a (HTTP, WebSockets, etc.) server. It handles the incoming requests, maps them into service calls, and then returns appropriate responses.

//////////////////////////////////////////////////////////////////////////////////////////////


Use case:

1.Create HelloWorld service, deploy on service broker, run on node, invoke.

Note: once Broker(engine), is ready only we can call service methods.

How to ensure broker ready, from where we call service methods.

Every thing is async.

broker starting is async
service call is also async.

flow should be like below
 broker returns promise, promise must be resolved-you have to call service inside then method of broker

const { ServiceBroker } = require('moleculer')

//create service broker object

const broker = new ServiceBroker();

//create service and deploy
// {} - service schema ; collection of service properties

broker.createService({
    name: 'hello',
    actions: {
        sayHello() {
            return 'Hello!Moleculer'
        }

    }
})
//
function main() {
    broker.start()
        .then(() => {
            console.log('Here only we can do service interaction')
            //call service
            broker.call('hello.sayHello')
                .then(data => {
                    console.log(data);
                })
                .catch(err => console.log('Service call failed ', err))

        })
        .catch(err => console.log('broker failed', err))
}
async function start() {
    try {
        await broker.start()
        const message = await broker.call('hello.sayHello')
        console.log(message);
    }
    catch (err) {
        console.log(err);
    }
}
start();
///////////////////////////////////////////////////////////////////////////////////////
Use case 2 ; multi methods:

const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//multiple service methods
broker.createService({
    name: 'profile',
    actions: {
        findAll() {
            return 'Profile findall'
        },
        save() {
            return 'profile save'
        },
        remove() {
            return 'profile remove'
        }

    }
});


async function init() {
    try {
        await broker.start();
        let response;
        response= await broker.call('profile.findAll')
        log(`${response}`)
        response= await broker.call('profile.save')
        log(`${response}`)
        response= await broker.call('profile.remove')
        log(`${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
//////////////////////////////////////////////////////////////////////////////////////////////////////

How to create multiple services?


const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();


broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

broker.createService({
    name: 'hai',
    actions: {
        //define biz api of that service
        sayHai() {
            return 'Hai,Molecular'
        }
    }
});


broker.createService({
    name: 'greet',
    actions: {
        //define biz api of that service
        sayGreet() {
            return 'Greet,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        response= await broker.call('hello.sayHello')
        log(`${response}`)
        response= await broker.call('hai.sayHai')
        log(`${response}`)
        response= await broker.call('greet.sayGreet')
        log(`${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
//
Use case : parameters to service methods

How to pass parameter to Service?

Any Service can take parameter, which type could be any thing: number,string,boolean,array,
object...

Syntax:

broker.call("serviceName.method",{p1:value1,p2:value2,pn:valueN})

Note: parameters must be encapsulated into an literal object

How to read args from the service Method?

Parameters are stored inside special object called "Context"

Context Object:

1.Similar to Broker Object
2.It has all capacity of Broker object
3.Context object is used inside service definitions , where ever you require broker
  Object reference.

context object already created, and its refernce is avaiable inside "Service method" as 
args.
const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello(ctx) {
            const { name } = ctx.params;
            return `Hello,${name}`;
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('hello.sayHello', { name: 'Subramanian' })
        log(response);
    }
    catch (e) {
        log(e);
    }
}
init();

/////////////////////////////////////////////////////////////////////////////////////////////////////

Params,handler , validation:

const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello(ctx) {
            const { name } = ctx.params;
            return `Hello,${name}`;
        }
    }
});
//adding validation to parameters, and  adding more behaviours
//behaviours are like validation,caching...
broker.createService({
    name: 'math',
    actions: {

        //add method with more behaviours
        add: {
            //validation behaviour
            params: {
                a: "number",
                b: "number"
            },
            //logic, inside a method called handler
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }

        }

    }
});


async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('hello.sayHello', { name: 'Subramanian' })
        log(response);
        let addresult
        addresult = await broker.call('math.add',{a:10,b:20});
        log(`Add Result is ${addresult}`);
        addresult = await broker.call('math.add',{a:'20',b:20});
        log(`Add Result is ${addresult}`);

    }
    catch (e) {
        log(e);
    }
}
init();
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Service Types:
.............

Back end services
------------------------
1.local services
2.remote services
3.public services
4.private services
---------------------------------
Front end services

5.End point service- rest api


1.local services :
 services are written and running on a "Single Service Broker  and Node".

how local services are communicating? service calls.

how to call service?

1.broker.call -  outside service
2.ctx.call -  service to service  

/**
 * Create two services , communicate them.
 * //Local Services
 */
const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//publisher service
broker.createService({
    name: 'publisher',
    actions: {
        add: {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
})


//consumer service
broker.createService({
    name: 'consumer',
    actions: {
        calculate: {
            async handler(ctx) {
                log('consumer - calculate')
                return  await ctx.call('publisher.add', { a: 10, b: 20 });
    
            }
        }
    }
})

async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('consumer.calculate')
        log(response)
    }
    catch (e) {
        log(e);
    }
}
init();
/////////////////////////////////////////////////////////////////////////////////////////////

REPL Tool : Read Evaulate Print Loop;

 For dev testing.

if i want to test a service with various different parameters during runtime.
if i want to adminster services

>npm install moleculer-repl --save-dev

const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//publisher service
broker.createService({
    name: 'addition',
    actions: {
        add: {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
})

async function init() {
    try {
        await broker.start();
        broker.repl();
    }
    catch (e) {
        log(e);
    }
}
init();


How to test?
C:\session\ibm\feb\nodems\basicmicroservice>node services/repl.service.js
[2021-02-05T05:54:09.213Z] INFO  laptop-r2tggfdl-26768/BROKER: Moleculer v0.14.12 is starting...
[2021-02-05T05:54:09.215Z] INFO  laptop-r2tggfdl-26768/BROKER: Namespace: <not defined>
[2021-02-05T05:54:09.216Z] INFO  laptop-r2tggfdl-26768/BROKER: Node ID: laptop-r2tggfdl-26768
[2021-02-05T05:54:09.217Z] INFO  laptop-r2tggfdl-26768/REGISTRY: Strategy: RoundRobinStrategy
[2021-02-05T05:54:09.218Z] INFO  laptop-r2tggfdl-26768/REGISTRY: Discoverer: LocalDiscoverer
[2021-02-05T05:54:09.227Z] INFO  laptop-r2tggfdl-26768/BROKER: Serializer: JSONSerializer
[2021-02-05T05:54:09.241Z] INFO  laptop-r2tggfdl-26768/BROKER: Validator: FastestValidator
[2021-02-05T05:54:09.244Z] INFO  laptop-r2tggfdl-26768/BROKER: Registered 13 internal middleware(s).
[2021-02-05T05:54:09.257Z] INFO  laptop-r2tggfdl-26768/REGISTRY: '$node' service is registered.
[2021-02-05T05:54:09.259Z] INFO  laptop-r2tggfdl-26768/REGISTRY: 'addition' service is registered.
[2021-02-05T05:54:09.260Z] INFO  laptop-r2tggfdl-26768/$NODE: Service '$node' started.
[2021-02-05T05:54:09.261Z] INFO  laptop-r2tggfdl-26768/ADDITION: Service 'addition' started.
[2021-02-05T05:54:09.263Z] INFO  laptop-r2tggfdl-26768/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 10ms.
mol $
mol $ call "addition.add"  --a 34 --b 10
>> Call 'addition.add' with params: { a: 34, b: 10 }
>> Execution time:2ms
>> Response:
44
mol $ call "addition.add"  --a 34 --b 90
>> Call 'addition.add' with params: { a: 34, b: 90 }
>> Execution time:570μs
>> Response:
124
mol $ q
[2021-02-05T05:55:08.718Z] INFO  laptop-r2tggfdl-26768/$NODE: Service '$node' stopped.
[2021-02-05T05:55:08.719Z] INFO  laptop-r2tggfdl-26768/ADDITION: Service 'addition' stopped.
[2021-02-05T05:55:08.719Z] INFO  laptop-r2tggfdl-26768/BROKER: ServiceBroker is stopped. Good bye.
/////////////////////////////////////////////////////////////////////////////////////////////

Remote Services:
................
 Services are deployed across the nodes/brokers

How to test services?

Open two cmd, run two different service programs

calculator ----communicate------adder

Service 1:
const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//consumer service
broker.createService({
    name: 'calculator',
    actions: {
        calculate: {
            async handler(ctx) {
                log('consumer - calculate')
                let result = await ctx.call('adder.add', { a: 10, b: 20 });
                log(`Result is ${result}`)
            }
        }
    }
})

async function init() {
    try {
        await broker.start();
        broker.repl();
    }
    catch (e) {
        log(e);
    }
}
init();


Service 2:

const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker();

//publisher service
broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
})
async function init() {
    try {
        await broker.start();
        broker.repl();
    }
    catch (e) {
        log(e);
    }
}
init();

when you run above code, you will get error.

>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
[2021-02-05T06:07:45.865Z] WARN  laptop-r2tggfdl-30520/BROKER: Service 'adder.add' is not registered.
>> ERROR:
ServiceNotFoundError: Service 'adder.add' is not found.
    at ServiceBroker.findNextActionEndpoint (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\service-broker.js:1025:13)
    at ServiceBroker.call (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\service-broker.js:1074:26)
    at Context.call (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\context.js:289:23)
    at Service.handler (C:\session\ibm\feb\nodems\basicmicroservice\services\remoteservice1.service.js:13:40)
    at C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\utils.js:182:22
    at ServiceBroker.timeoutMiddleware (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\middlewares\timeout.js:35:14)
    at ServiceBroker.fallbackMiddleware (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\middlewares\fallback.js:29:11)
    at ServiceBroker.errorHandlerMiddleware (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\middlewares\error-handler.js:14:10)
    at ServiceBroker.call (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer\src\service-broker.js:1089:31)
    at call (C:\session\ibm\feb\nodems\basicmicroservice\node_modules\moleculer-repl\src\commands\call.js:88:9)
Data:  { action: 'adder.add' }
mol $

if you start calling, you will get the error 

>> ERROR:
ServiceNotFoundError: Service 'publisher.add' is not found.


How to communicate remote services?

We need some infra software and transporter

Transporters:

Transporter is an important module if you are running services on multiple nodes. 

Transporter communicates with other nodes. 

It transfers events, calls requests and processes responses …etc. 

If a service runs on multiple instances on different nodes, the requests will be load-balanced among live nodes.


Transports:
............

Built-in transporters

TCP transporter
NATS Transporter
Redis Transporter
MQTT Transporter
AMQP Transporter
Kafka Transporter
NATS Streaming (STAN) Transporter

////////////////////////////////////////////////////////////////////////////////////////////

const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker({
    transporter: "nats://localhost:4444"
});

//consumer service
broker.createService({
    name: 'calculator',
    actions: {
        calculate: {
            async handler(ctx) {
                log('consumer - calculate')
                let result = await ctx.call('adder.add', { a: 10, b: 20 });
                log(`Result is ${result}`)
            }
        }
    }
})

async function init() {
    try {
        await broker.start();
        broker.repl();
    }
    catch (e) {
        log(e);
    }
}
init();


const { ServiceBroker } = require('moleculer');
const { log } = console;

const broker = new ServiceBroker({
    transporter: "nats://localhost:4444"
});

//publisher service
broker.createService({
    name: 'adder',
    actions: {
        add: {
            params: {
                a: "number",
                b: "number"
            },
            handler(ctx) {
                const { a, b } = ctx.params;
                return a + b;
            }
        }
    }
})
async function init() {
    try {
        await broker.start();
        broker.repl();
    }
    catch (e) {
        log(e);
    }
}
init();


steps:

1.start any transporter

eg: nats,redis..

docker run -p 4444:4444 nats -p 4444


2.transporter configuration in service

const broker = new ServiceBroker({
    transporter: "nats://nats.server:4222"
});

3.npm install nats --save

Testing:
C:\session\ibm\feb\nodems\basicmicroservice>node services/remoteservice1.service.js
[2021-02-05T06:20:16.473Z] INFO  laptop-r2tggfdl-31036/BROKER: Moleculer v0.14.12 is starting...
[2021-02-05T06:20:16.476Z] INFO  laptop-r2tggfdl-31036/BROKER: Namespace: <not defined>
[2021-02-05T06:20:16.476Z] INFO  laptop-r2tggfdl-31036/BROKER: Node ID: laptop-r2tggfdl-31036
[2021-02-05T06:20:16.477Z] INFO  laptop-r2tggfdl-31036/REGISTRY: Strategy: RoundRobinStrategy
[2021-02-05T06:20:16.479Z] INFO  laptop-r2tggfdl-31036/REGISTRY: Discoverer: LocalDiscoverer
[2021-02-05T06:20:16.487Z] INFO  laptop-r2tggfdl-31036/BROKER: Serializer: JSONSerializer
[2021-02-05T06:20:16.496Z] INFO  laptop-r2tggfdl-31036/BROKER: Validator: FastestValidator
[2021-02-05T06:20:16.497Z] INFO  laptop-r2tggfdl-31036/BROKER: Registered 13 internal middleware(s).
[2021-02-05T06:20:16.499Z] INFO  laptop-r2tggfdl-31036/BROKER: Transporter: NatsTransporter
[2021-02-05T06:20:16.509Z] INFO  laptop-r2tggfdl-31036/TRANSIT: Connecting to the transporter...
[2021-02-05T06:20:16.537Z] INFO  laptop-r2tggfdl-31036/TRANSPORTER: NATS client is connected.
[2021-02-05T06:20:16.545Z] INFO  laptop-r2tggfdl-31036/REGISTRY: Node 'laptop-r2tggfdl-31492' connected.
[2021-02-05T06:20:17.048Z] INFO  laptop-r2tggfdl-31036/REGISTRY: '$node' service is registered.
[2021-02-05T06:20:17.050Z] INFO  laptop-r2tggfdl-31036/REGISTRY: 'calculator' service is registered.
[2021-02-05T06:20:17.051Z] INFO  laptop-r2tggfdl-31036/$NODE: Service '$node' started.
[2021-02-05T06:20:17.051Z] INFO  laptop-r2tggfdl-31036/CALCULATOR: Service 'calculator' started.
[2021-02-05T06:20:17.054Z] INFO  laptop-r2tggfdl-31036/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 546ms.
mol $ call "calculator.calculate" --a 10 --b 20
>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
Result is 30
>> Execution time:11ms
>> Response:
undefined
mol $


C:\session\ibm\feb\nodems\basicmicroservice>node services/remoteservice2.service.js
[2021-02-05T06:20:04.284Z] INFO  laptop-r2tggfdl-31492/BROKER: Moleculer v0.14.12 is starting...
[2021-02-05T06:20:04.286Z] INFO  laptop-r2tggfdl-31492/BROKER: Namespace: <not defined>
[2021-02-05T06:20:04.287Z] INFO  laptop-r2tggfdl-31492/BROKER: Node ID: laptop-r2tggfdl-31492
[2021-02-05T06:20:04.288Z] INFO  laptop-r2tggfdl-31492/REGISTRY: Strategy: RoundRobinStrategy
[2021-02-05T06:20:04.289Z] INFO  laptop-r2tggfdl-31492/REGISTRY: Discoverer: LocalDiscoverer
[2021-02-05T06:20:04.296Z] INFO  laptop-r2tggfdl-31492/BROKER: Serializer: JSONSerializer
[2021-02-05T06:20:04.305Z] INFO  laptop-r2tggfdl-31492/BROKER: Validator: FastestValidator
[2021-02-05T06:20:04.308Z] INFO  laptop-r2tggfdl-31492/BROKER: Registered 13 internal middleware(s).
[2021-02-05T06:20:04.309Z] INFO  laptop-r2tggfdl-31492/BROKER: Transporter: NatsTransporter
[2021-02-05T06:20:04.318Z] INFO  laptop-r2tggfdl-31492/TRANSIT: Connecting to the transporter...
[2021-02-05T06:20:04.350Z] INFO  laptop-r2tggfdl-31492/TRANSPORTER: NATS client is connected.
[2021-02-05T06:20:04.858Z] INFO  laptop-r2tggfdl-31492/REGISTRY: '$node' service is registered.
[2021-02-05T06:20:04.860Z] INFO  laptop-r2tggfdl-31492/REGISTRY: 'adder' service is registered.
[2021-02-05T06:20:04.860Z] INFO  laptop-r2tggfdl-31492/$NODE: Service '$node' started.
[2021-02-05T06:20:04.861Z] INFO  laptop-r2tggfdl-31492/ADDER: Service 'adder' started.
[2021-02-05T06:20:04.865Z] INFO  laptop-r2tggfdl-31492/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 547ms.
mol $ [2021-02-05T06:20:17.055Z] INFO  laptop-r2tggfdl-31492/REGISTRY: Node 'laptop-r2tggfdl-31036' connected.
/////////////////////////////////////////////////////////////////////////////////////////////

Registery and Discovery: Service Registry
.........................................


1.Service Registry

 It is mini /small database , key-value pair database, in memory database.
 Which has all service,actions,event listeners, nodes information.


Points:
1.Every Broker has in built Service Registry
     Moleculer has built in in-memory registry, we can use that registry directly.

2.All services local or remote are registered with service registry as soon you create 
  service
3.Molecular has built in registry called LocalDiscoveryRegistry, which is not using third party registry servers
  like apache zoo keeper,cosule,etcd,eurka....

4.if you want to make other servers as service registry -

    registry: {
        discoverer: "redis://redis-server:6379"
    }  
Dynamic service discovery
1.Local
2.Redis
3.etcd3
4.Customization

Lab:
How to use redis as registry server.

Steps:

1.start redis server

docker run  -p 6379:6379 redis


2.install redis module 
npm install ioredis --save

3.Service Registry Conguration.
const broker = new ServiceBroker({
    transporter: "nats://localhost:4444",
    registry: {
        discoverer: "redis://localhost:6379"
    } 
});

Steps:

1.start redis server

docker run  -p 6379:6379 redis


2.install redis module 
npm install ioredis --save

3.Service Registry Conguration.
const broker = new ServiceBroker({
    transporter: "nats://localhost:4444",
    registry: {
        discoverer: "redis://localhost:6379"
    } 
});

4.start services , see the message below
[2020-09-17T06:30:21.545Z] INFO  laptop-r2tggfdl-14456/REGISTRY: Strategy: RoundRobinStrategy
[2020-09-17T06:30:21.546Z] INFO  laptop-r2tggfdl-14456/REGISTRY: Discoverer: RedisDiscoverer

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Load balancing means , distributing load to different machines in the cluster.

In distributed computing, one server may not be enough to  handle load.

1.Moleculer has several built-in load balancing strategies.

Built-in strategies

 ->RoundRobin strategy
	This strategy selects a node based on round-robin algorithm.
   Refer:https://en.wikipedia.org/wiki/Round-robin_DNS
 ->Random strategy
	This strategy selects a node randomly.
 ->CPU usage-based strategy
	This strategy selects a node which has the lowest CPU usage. Due to the node list can 	be very long, it gets samples and selects the node with the lowest CPU usage from only 	samples instead of the whole node list.

 ->Latency-based strategy
	This strategy selects a node which has the lowest latency, measured by periodic ping commands. Notice that the strategy only ping one of nodes from a single host.

Demo:

steps:

1.start Calculator service

2.start adder service 2 instances.

3. Call calculator to adder  and see which instance is giving result.
                            
                           |--adder
  Calculator --------------|
                            --adder
  
 network+service discovery+loadbalancing


Testing : 

Run 2 instances of adder services:
C:\session\ibm\feb\nodems\basicmicroservice>node services/remoteservice2.service.js
[2021-02-05T06:58:04.852Z] INFO  laptop-r2tggfdl-13756/BROKER: Moleculer v0.14.12 is starting...
[2021-02-05T06:58:04.855Z] INFO  laptop-r2tggfdl-13756/BROKER: Namespace: <not defined>
[2021-02-05T06:58:04.856Z] INFO  laptop-r2tggfdl-13756/BROKER: Node ID: laptop-r2tggfdl-13756
[2021-02-05T06:58:04.861Z] INFO  laptop-r2tggfdl-13756/REGISTRY: Strategy: RoundRobinStrategy
[2021-02-05T06:58:04.866Z] INFO  laptop-r2tggfdl-13756/REGISTRY: Discoverer: LocalDiscoverer
[2021-02-05T06:58:04.882Z] INFO  laptop-r2tggfdl-13756/BROKER: Serializer: JSONSerializer
[2021-02-05T06:58:04.899Z] INFO  laptop-r2tggfdl-13756/BROKER: Validator: FastestValidator
[2021-02-05T06:58:04.907Z] INFO  laptop-r2tggfdl-13756/BROKER: Registered 13 internal middleware(s).
[2021-02-05T06:58:04.912Z] INFO  laptop-r2tggfdl-13756/BROKER: Transporter: NatsTransporter
[2021-02-05T06:58:04.929Z] INFO  laptop-r2tggfdl-13756/TRANSIT: Connecting to the transporter...
[2021-02-05T06:58:04.966Z] INFO  laptop-r2tggfdl-13756/TRANSPORTER: NATS client is connected.
[2021-02-05T06:58:05.491Z] INFO  laptop-r2tggfdl-13756/REGISTRY: '$node' service is registered.
[2021-02-05T06:58:05.502Z] INFO  laptop-r2tggfdl-13756/REGISTRY: 'adder' service is registered.
[2021-02-05T06:58:05.508Z] INFO  laptop-r2tggfdl-13756/$NODE: Service '$node' started.
[2021-02-05T06:58:05.511Z] INFO  laptop-r2tggfdl-13756/ADDER: Service 'adder' started.
[2021-02-05T06:58:05.520Z] INFO  laptop-r2tggfdl-13756/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 592ms.
mol $ [2021-02-05T06:58:33.477Z] INFO  laptop-r2tggfdl-13756/REGISTRY: Node 'laptop-r2tggfdl-21280' connected.
[2021-02-05T06:59:00.435Z] INFO  laptop-r2tggfdl-13756/REGISTRY: Node 'laptop-r2tggfdl-29932' connected.


C:\session\ibm\feb\nodems\basicmicroservice>node services/remoteservice1.service.js
[2021-02-05T06:58:59.786Z] INFO  laptop-r2tggfdl-29932/BROKER: Moleculer v0.14.12 is starting...
[2021-02-05T06:58:59.788Z] INFO  laptop-r2tggfdl-29932/BROKER: Namespace: <not defined>
[2021-02-05T06:58:59.789Z] INFO  laptop-r2tggfdl-29932/BROKER: Node ID: laptop-r2tggfdl-29932
[2021-02-05T06:58:59.790Z] INFO  laptop-r2tggfdl-29932/REGISTRY: Strategy: RoundRobinStrategy
[2021-02-05T06:58:59.791Z] INFO  laptop-r2tggfdl-29932/REGISTRY: Discoverer: LocalDiscoverer
[2021-02-05T06:58:59.802Z] INFO  laptop-r2tggfdl-29932/BROKER: Serializer: JSONSerializer
[2021-02-05T06:58:59.814Z] INFO  laptop-r2tggfdl-29932/BROKER: Validator: FastestValidator
[2021-02-05T06:58:59.817Z] INFO  laptop-r2tggfdl-29932/BROKER: Registered 13 internal middleware(s).
[2021-02-05T06:58:59.820Z] INFO  laptop-r2tggfdl-29932/BROKER: Transporter: NatsTransporter
[2021-02-05T06:58:59.838Z] INFO  laptop-r2tggfdl-29932/TRANSIT: Connecting to the transporter...
[2021-02-05T06:58:59.872Z] INFO  laptop-r2tggfdl-29932/TRANSPORTER: NATS client is connected.
[2021-02-05T06:58:59.883Z] INFO  laptop-r2tggfdl-29932/REGISTRY: Node 'laptop-r2tggfdl-21280' connected.
[2021-02-05T06:58:59.889Z] INFO  laptop-r2tggfdl-29932/REGISTRY: Node 'laptop-r2tggfdl-13756' connected.
[2021-02-05T06:59:00.391Z] INFO  laptop-r2tggfdl-29932/REGISTRY: '$node' service is registered.
[2021-02-05T06:59:00.398Z] INFO  laptop-r2tggfdl-29932/REGISTRY: 'calculator' service is registered.
[2021-02-05T06:59:00.421Z] INFO  laptop-r2tggfdl-29932/$NODE: Service '$node' started.
[2021-02-05T06:59:00.424Z] INFO  laptop-r2tggfdl-29932/CALCULATOR: Service 'calculator' started.
[2021-02-05T06:59:00.435Z] INFO  laptop-r2tggfdl-29932/BROKER: ✔ ServiceBroker with 2 service(s) is started successfully in 598ms.
mol $ call "calculator.calculate" --a 10 --b 20
>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
Result is The 30 from laptop-r2tggfdl-21280
>> Execution time:38ms
>> Response:
undefined
mol $ call "calculator.calculate" --a 10 --b 20
>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
Result is The 30 from laptop-r2tggfdl-13756
>> Execution time:18ms
>> Response:
undefined
mol $ call "calculator.calculate" --a 10 --b 20
>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
Result is The 30 from laptop-r2tggfdl-21280
>> Execution time:11ms
>> Response:
undefined
mol $ call "calculator.calculate" --a 10 --b 20
>> Call 'calculator.calculate' with params: { a: 10, b: 20 }
consumer - calculate
Result is The 30 from laptop-r2tggfdl-13756
>> Execution time:16ms
>> Response:
undefined
mol $
//////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////

Service inheritance:

Objective:

 lets say i have a service having more methods, that i dont want to give in a service
 i have service , that service apis , i want to reuse in service apis

Service inheritance comes into place.

In molecular , a service can inherit many services - multi level, for multi level, molcular uses
a concept called "mixins".

////////////////////////////////////////////////////////////////////////////////////////////////////////

Service inheritance:

Objective:

 lets say i have a service having more methods, that i dont want to give in a service
 i have service , that service apis , i want to reuse in service apis

Service inheritance comes into place.

In molecular , a service can inherit many services - multi level, for multi level, molcular uses
a concept called "mixins".

Use case:
1.if you write any REST Controller.
2.if you write database operations inside your service.

parent.service.js

module.exports = {
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
};


child

const { ServiceBroker } = require('moleculer');
const hello = require('./parent.service');
const { log } = console;
const broker = new ServiceBroker();


broker.createService({
    name: 'greeter',
    mixins: [hello],
    actions: {
        sayGreet:{
            handler(){
                return 'Greet';
            }
        }
    }
});


async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('greeter.sayHello')
        log(`${response}`)
        response = await broker.call('greeter.sayGreet')
        log(`${response}`)

    }
    catch (e) {
        log(e);
    }
}
init();
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Events:

How services can communicate without calling directly and passing messages among them?

event emitter, pattern.

Services can register for events, other services can emit/broadcast events
Services can send events along with data.



Steps:

1.Register events

 events: {
        "user.created"(payload) {
            log("User created:", payload);
            // Do something
        }
    }

2.send data via events

broker.emit('nameofevent',data)
context.emit('nameofevent',data);

const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

//Listener service
broker.createService({
    name:'reportlistner',
    events: {
        "user.created"(payload) {
            this.logger.info("User created:", payload);
            // Do something
        }
    }
});

broker.createService({
    name:'reportsender',
    actions:{
        sendReport(ctx){
            let user = {
                id: 1,
                name: 'subramanian'
            }
            ctx.emit("user.created", { entity: user });
            return `Report has been sent`
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('reportsender.sendReport');
        log(response);

    }
    catch (e) {
        log(e);
    }
}
init();



/////////////////

Molecular methods

1.public methods / service methods
 actions:{
    sayHello(){}
 }
2.Private methods

3.life cycle methods

4.HTTP end point methods.


Private methods:

const { ServiceBroker } = require('moleculer');
const { log } = console;
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        //public methods
        calculate(ctx) {
          //calling private method
          const result=this.add(ctx.params.a,ctx.params.b);
          return result
        }
    },
    //private methods
    methods: {
        add(a,b){
            return a +b;
        }
    }
});

async function init() {
    try {
        await broker.start();
        let response;
        //calling public methods
        response = await broker.call('math.calculate', { a: 10, b: 20 });
        log(response);

    }
    catch (e) {
        log(e);
    }
}
init();

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
life cyle methods:
...................


const { ServiceBroker } = require('moleculer');
const broker = new ServiceBroker();

broker.createService({
    name: 'math',
    actions: {
        add(ctx) {
            return ctx.params.a + ctx.params.b;
        }
    },
    //life cycle methods
    created() {
        // Fired when the service instance created (with `broker.loadService` or `broker.createService`)
        this.logger.info("created");
    },

    async started() {
        // Fired when broker starts this service (in `broker.start()`)
        this.logger.info("started");
    },
    async stopped() {
        // Fired when broker stops this service (in `broker.stop()`)
        this.logger.info("stoped");
    }
})


async function init() {
    try {
        await broker.start();
        let response;
        response = await broker.call('math.add', { a: 1, b: 3 })
        console.log(`response ${response}`)
    }
    catch (e) {
        log(e);
    }
}
init();
////////////////////////////////////////////////////////////////////////////////////////////////////////


Mixin:
   Help to integrate any plugin into our services

Modules:
 How integrate modules into our app, via "mixins" only.


1.back end service
  service which is having application logic.

2.front end service /api gate way service.
  Service which exposes apis are as "Rest End points".


1.Mixin :api gate way


API GATE Implementation:
Molecular provides lot of modules 

1.moleculer-web

moleculer-web is official gatway module, which is built on express.js


Rest Service:

Simple:

const { ServiceBroker } = require('moleculer');
let ApiService = require("moleculer-web");

const { log } = console;

const broker = new ServiceBroker();


broker.createService({
    name:'apigateway',
    mixins:[ApiService],
    settings: {
        routes:[{
            path:"/api",
            whitelist: [
                // Access any actions in 'hello' service
                "hello.*",
            ]
        }]
    }
});


broker.createService({
    name: 'hello',
    actions: {
        //define biz api of that service
        sayHello() {
            return 'Hello,Molecular'
        }
    }
});

async function init() {
    try {
        await broker.start();
        }
    catch (e) {
        log(e);
    }
}
init();

url mapping;
http://localhost:3000/api/hello/sayHello



Aliases:
.........

You can use alias names instead of action names. You can also specify the method. 
Otherwise it will handle every method types.

http://localhost:3000/api/hello/

broker.createService({
    name:'apigateway',
    mixins:[ApiService],
    settings: {
        routes:[{
            path:"/api",
            aliases: {
               "hello": "hello.sayHello"
            }
        }]
    }
});
//////////////////////////////////////////////////////////////////////////////////////////////

Moleculer Runner

-Helper script to create realtime projects

-all necessary configuration.
  -GATEWAY
  -Transporter
  -Database integration
  -Docker/Kb integration
  -Monitoring tool integration


Steps:

1.install
npm i -g moleculer-cli

2.Create Project
$ moleculer init project my-project


Artifacts in the project:

1.package.json

2.moleculer.config.js
    Broker configuration 
   
3.services folder
	


















































































































































