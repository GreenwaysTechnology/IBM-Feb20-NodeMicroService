                                          Node JS
//////////////////////////////////////////////////////////////////////////////////////////////

What is Node.js?

Why Node.js?

How to start writing apps on Node.js
///////////////////////////////////////////////////////////////////////////////////////

What is Node.js?
   Node.jsÂ® is a JavaScript runtime built on Chrome's V8 JavaScript engine.

What is V8?
  V8 is Googleâ€™s open source high-performance JavaScript and WebAssembly engine, written in C++. 
It is used in Chrome and in Node.js, among others. It implements ECMAScript and WebAssembly

Java script core Features:

1.javascript programs are executed by javascript engine.

Java Script Engine Design:

-Single threaded - never allows to create application threads.

Having single thread , how we can run multiple tasks at the same time?
 -Async Programming
 -Callback Programming
 -Worker thread model.

ajax call - async java script and xml

java
  -connect database - thread
  -start socket - thread

 
Blocking and NonBlocking :

 Blocking means, if a thread is created which is blocked for some io like database,network connection.
if more blocked threads will lead , performance issue, may crash the whole server.
............................................................................................

Blocking and Server side Java(Tomcat)
......................................

Traditionally tomcat(jvm), uses multi threaded model.
Each request is treated as a single thread, each thread may do some io operation


Non Blocking:
 thread is not blocked for any request, rather which uses worker-thread model.

//////////////////////////////////////////////////////////////////////////////////////////

Node Arch idea:

 - single threaded
 - nonblocking networking application
 - async programming using libuv.
 - using javascript language.

             Node is non blocking,async,event driven io platform.
////////////////////////////////////////////////////////////////////////////////////////////

Node architecture:

JAVASCRIPT Modularity : Commonjs

Node platform apis 
  -event emitters
  -io
  -network - web
NPM

Frameworks
 -REST API
 -Micro services 
////////////////////////////////////////////////////////////////////////////////////

Node is not only runtime but we call platform.

Platform is nothing collection of many compoents


Blocking apis

Linux:

1.read



Non blocking implementation apis:

Linux:

1.select
   select is the first api introduced to perform non blocking operations 
   select has some drawabacks.

2.poll 
   poll api was introduced later in order to avoid some drawbacks in select.


3.epoll
   poll has some complexity in usage.
   epoll is small event notification and non blocking framework.
////////////////////////////////////////////////////////////////////////////////////////////
1.v8 engine
  Which is from goolgle.
  Supports all javascript language spec.
  Which was developed only for browser.
  Node creator wanted to build web,file system io,network io application.
  but there is no api available in javascript language.
  who wanted to add new apis on v8.
  V8 is written i C++.

2.Node binding c layer:
  node creator who created low level system calls to build io applications.
  written c language
 Node binding java script language which high level javascript apis 

3.libvu

 libuv is a multi-platform support library with a focus on asynchronous I/O. It was primarily developed for use by Node.js, but itâ€™s also used by Luvit, Julia, pyuv, and others.
//////////////////////////////////////////////////////////////////////////////////////////////

node apps - javascript apps:
...........................

Javascript modularity:

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Modularity:
..........

In java Modularity , is presented via "Packages"

Package organize the code  logically.

Customer.java

package com.ibm.cms

public class Customer{}

Java organizes code folders and files Physically.

d:/javaapps/src/
    com/ibm/cms/Customer.java


What about javascript Modularity?

 Javascript is file based modularity physically
 but logically there is no such modularity at language level.

 collection of variable declarations and function.

Once js started growing in large scale, dev struck to organize code.

2000, Smart developers started thinking about how to modualrize js code.
 

Module design patterns came.

1.Namespace design pattern : 2000 : jquery
2.AMD -Async Module Defintion : dojo
---------------------------------------------------------
3.CJS - Common JS =  namespace + amd
4.ES 6 Module design pattern  = amd + cjs
------------------------------------------------------------
5.System = AMD = CJS + ES 6
6.UMD = NAMESPACE + AMD + CJS = ES 6


only two design patterns are used in development

1.CJS - Common JS =  namespace + amd
2.ES 6 Module design pattern  = amd + cjs

CJS ; implemented inside node js. node supports commonjs by default.

I can organize the code , based on these patterns, but what about runtimes?
  js runtime never suppport these patterns directly then each design pattern is lib.

 Loaders : it is simple js lib to help link and load js files.


lets start cjs first;
......................

cjs is built in node js.
node supports cjs in built. no separate loader or linker is required
but if you run cjs code on browsers , we need loaders.
/////////////////////////////////////////////////////////////////////////////////////////////////////
Object augmentation:

In javascript objects are simple map/dictionary.

Since object is datastructure , we can add,delete,update,iterate object properties dynamically.
 This is called as "Object augmentation".
//object augmentation;

//object has no any property ; empty object
let product = {
   id:1
};
console.log(product)
//object augmentation: adding new property 
product.name = "Phone"
product.qty =100
product.price=0;
console.log(product)
//object augmentation: update new property 
//if property exits, it updates, if not , add 
product.price=100;
console.log(product)
//object augmentation: remove new property 
delete product.qty;
console.log(product)
//object augmentation ; iterate
for(let prop in product){
    console.log(prop,product[prop])
}
/////////////////////////////////////////////////////////////////////////////////////////////

COMMONJS : CJS

Code sharing among files.

What could be code?
could be variable declaration,class declaration,function declaration.

Linking files :


cjs provides some keywords

require() - function -  linking files

exports,module.exports - built in variables  : code sharing


How to link files?

src/index.js

require('./mylib')

src/mylib.js

console.log('mylib')

How to share code?
 variables,functions,class..

exports:
 -exports is built in variable.
 -exports has some default value.

require('file'): function call

 -parameter is file name
 -return value is literal object with respect to exports

let myresult = require('file')

The default value is empty literal object.
//////////////////

src/info.js

//code sharing -  exports

//exports = {}
//augment empty object pointed by exports variable
exports.message = "Hello"
exports.rank=10
exports.isActive=true;
exports.doSomething = function(){
    return "something"
}
exports.address = {
    city:'Coimbatore',
    state:'Tamil Nadu',
}
/////////////
src/index.js
// const res = require('./info')

// console.log(res)

// console.log(res.message,res.rank,res.isActive,res.doSomething())
const { message, rank, isActive, doSomething, address: { city, state } } = require('./info');

console.log(message, rank, isActive, doSomething(),city,state)
///////////////////////////////////////////////////////////////////////////////////////////

module.exports: another way of sharing code
............................................

exports vs module.exports

1.exports will export the entire as single object.
2.where as module.exports , wont export code as object, rahter which exports code as it is.

module.exports will be suitable single exports.
 -you have class
 -you have function
 -you have variable having arrays.

with require() , will not return object,rather which returns what you have returned(fun,varible,object,class).


src/GreeterService.js

class GreeterService{
    constructor(){
        console.log('Greeter service is initlaized')
    }
    //biz apis
    sayHai(){
        return 'Hai'
    }
    sayHello(){
        return 'Hello'
    }
    sayGreet(){
        return 'Greet'
    }
}

//here we pack class 
//module.exports = GreeterService;
//here we pack object
module.exports = new GreeterService();

src/index.js
// const GreeterService = require('./GreeterService')

// let service = new GreeterService();
// console.log(service.sayHai());
// console.log(service.sayGreet())

const {sayGreet,sayHai} = require('./GreeterService');
const {log} = console

log(sayHai());
log(sayGreet())
//////////////////////////////////////////////////////////////////////////////////////////////

src/mock-data/users.js
const USERS=[
    {
        id: 1,
        name: "Leanne Graham",
        username: "Bret",
        email: "Sincere@april.biz",
        address: {
            street: "Kulas Light",
            suite: "Apt. 556",
            city: "Gwenborough",
            zipcode: "92998-3874",
            geo: {
                lat: "-37.3159",
                lng: "81.1496"
            }
        },
        phone: "1-770-736-8031 x56442",
        website: "hildegard.org",
        company: {
            name: "Romaguera-Crona",
            catchPhrase: "Multi-layered client-server neural-net",
            bs: "harness real-time e-markets"
        }
    },
    {
        id: 2,
        name: "Ervin Howell",
        username: "Antonette",
        email: "Shanna@melissa.tv",
        address: {
            street: "Victor Plains",
            suite: "Suite 879",
            city: "Wisokyburgh",
            zipcode: "90566-7771",
            geo: {
                lat: "-43.9509",
                lng: "-34.4618"
            }
        },
        phone: "010-692-6593 x09125",
        website: "anastasia.net",
        company: {
            name: "Deckow-Crist",
            catchPhrase: "Proactive didactic contingency",
            bs: "synergize scalable supply-chains"
        }
    },
    {
        id: 3,
        name: "Clementine Bauch",
        username: "Samantha",
        email: "Nathan@yesenia.net",
        address: {
            street: "Douglas Extension",
            suite: "Suite 847",
            city: "McKenziehaven",
            zipcode: "59590-4157",
            geo: {
                lat: "-68.6102",
                lng: "-47.0653"
            }
        },
        phone: "1-463-123-4447",
        website: "ramiro.info",
        company: {
            name: "Romaguera-Jacobson",
            catchPhrase: "Face to face bifurcated interface",
            bs: "e-enable strategic applications"
        }
    },
    {
        id: 4,
        name: "Patricia Lebsack",
        username: "Karianne",
        email: "Julianne.OConner@kory.org",
        address: {
            street: "Hoeger Mall",
            suite: "Apt. 692",
            city: "South Elvis",
            zipcode: "53919-4257",
            geo: {
                lat: "29.4572",
                lng: "-164.2990"
            }
        },
        phone: "493-170-9623 x156",
        website: "kale.biz",
        company: {
            name: "Robel-Corkery",
            catchPhrase: "Multi-tiered zero tolerance productivity",
            bs: "transition cutting-edge web services"
        }
    },
    {
        id: 5,
        name: "Chelsey Dietrich",
        username: "Kamren",
        email: "Lucio_Hettinger@annie.ca",
        address: {
            street: "Skiles Walks",
            suite: "Suite 351",
            city: "Roscoeview",
            zipcode: "33263",
            geo: {
                lat: "-31.8129",
                lng: "62.5342"
            }
        },
        phone: "(254)954-1289",
        website: "demarco.info",
        company: {
            name: "Keebler LLC",
            catchPhrase: "User-centric fault-tolerant solution",
            bs: "revolutionize end-to-end systems"
        }
    },
    {
        id: 6,
        name: "Mrs. Dennis Schulist",
        username: "Leopoldo_Corkery",
        email: "Karley_Dach@jasper.info",
        address: {
            street: "Norberto Crossing",
            suite: "Apt. 950",
            city: "South Christy",
            zipcode: "23505-1337",
            geo: {
                lat: "-71.4197",
                lng: "71.7478"
            }
        },
        phone: "1-477-935-8478 x6430",
        website: "ola.org",
        company: {
            name: "Considine-Lockman",
            catchPhrase: "Synchronised bottom-line interface",
            bs: "e-enable innovative applications"
        }
    },
    {
        id: 7,
        name: "Kurtis Weissnat",
        username: "Elwyn.Skiles",
        email: "Telly.Hoeger@billy.biz",
        address: {
            street: "Rex Trail",
            suite: "Suite 280",
            city: "Howemouth",
            zipcode: "58804-1099",
            geo: {
                lat: "24.8918",
                lng: "21.8984"
            }
        },
        phone: "210.067.6132",
        website: "elvis.io",
        company: {
            name: "Johns Group",
            catchPhrase: "Configurable multimedia task-force",
            bs: "generate enterprise e-tailers"
        }
    },
    {
        id: 8,
        name: "Nicholas Runolfsdottir V",
        username: "Maxime_Nienow",
        email: "Sherwood@rosamond.me",
        address: {
            street: "Ellsworth Summit",
            suite: "Suite 729",
            city: "Aliyaview",
            zipcode: "45169",
            geo: {
                lat: "-14.3990",
                lng: "-120.7677"
            }
        },
        phone: "586.493.6943 x140",
        website: "jacynthe.com",
        company: {
            name: "Abernathy Group",
            catchPhrase: "Implemented secondary concept",
            bs: "e-enable extensible e-tailers"
        }
    },
    {
        id: 9,
        name: "Glenna Reichert",
        username: "Delphine",
        email: "Chaim_McDermott@dana.io",
        address: {
            street: "Dayna Park",
            suite: "Suite 449",
            city: "Bartholomebury",
            zipcode: "76495-3109",
            geo: {
                lat: "24.6463",
                lng: "-168.8889"
            }
        },
        phone: "(775)976-6794 x41206",
        website: "conrad.com",
        company: {
            name: "Yost and Sons",
            catchPhrase: "Switchable contextually-based project",
            bs: "aggregate real-time technologies"
        }
    },
    {
        id: 10,
        name: "Clementina DuBuque",
        username: "Moriah.Stanton",
        email: "Rey.Padberg@karina.biz",
        address: {
            street: "Kattie Turnpike",
            suite: "Suite 198",
            city: "Lebsackbury",
            zipcode: "31428-2261",
            geo: {
                lat: "-38.2386",
                lng: "57.2232"
            }
        },
        phone: "024-648-3804",
        website: "ambrose.net",
        company: {
            name: "Hoeger LLC",
            catchPhrase: "Centralized empowering task-force",
            bs: "target end-to-end models"
        }
    }
];

module.exports = USERS;
//////////////////////////////////////////////////////////////////////////////////////////////
src/services/UserService.js

const USERS = require('../mockdata/users-mock')

class UserService {
    constructor() {

    }
    findAll() {
        return USERS;
    }
}
module.exports = new UserService();


const {findAll} = require('./services/UserService');

console.log(findAll())
/////////////////////////////////////////////////////////////////////////////////////////////

How to async programming?

All apis are not async.

How to know async apis?

async api are provided by javascript and node platform.

callback function
 are normal functions which are called because of event notification.
 callbacks function are called by event loop(thread)
 callback functions are called when result is ready only.

callbacks are passed as parameter to another function(caller)


1.api
2.callback
3.registeration by caller.

Apis:
javascript specific apis
1.timers
  -settimeout
  -setinterval
2.ajax - network calls
3.websocket
4.dom apis
etc....

Node platform api
1.timers
2.io apis
3.networking apis
etc....


Styles of async programming:

1.callback - core style
  callbacks has some drawbacks.
2.promises
3.async await.

Demo:

1.callback based programming

//timer and style is callback.

// function delay(callback) {
//     setTimeout(callback, 1000,'I am delayed');
// }
const delay = callback => setTimeout(callback, 1000, 'I am delayed')
//passing function
console.log('start')
delay(data => console.log(data));
console.log('end')

const heartBeat = callback=>{
  const timerId= setInterval(callback,1000,new Date())
  //stop the interval
  setTimeout(()=>{
      console.log('stopping task')
      //stopping
       clearInterval(timerId);
  },5000)

}
heartBeat(now=>console.log(now))
/////////////////////////////////////////////////////////////////////////////////////////////
//callback nesting/compostion

const getUser = (resolve, reject) => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //  user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        setTimeout(resolve, 1000, user)
    } else {
        setTimeout(reject, 1000, err)
    }
};
//Login function is called with user as input.
const login = (user, resolve, reject) => {
    let status = "Login success"
    let err = "Login failed"
    //bizlogic
    if (user.name === 'admin') {
        setTimeout(resolve, 1000, status)
    } else {
        setTimeout(reject, 1000, err)
    }
}

const showpage = (status, resolve, reject) => {
    //biz logic
    if (status === 'Login success') {
        setTimeout(resolve, 1000, { message: 'You are admin' });
    } else {
        setTimeout(reject, 1000, { message: 'You are guest' });
    }

}


getUser(user => {
    console.log('get User is called')
    login(user, status => {
        console.log('login is called')
        showpage(status, who => {
            console.log('show page is called')
            console.log(who)
        }, error => {
            console.log(error)
        })
    }, err => {
        console.log(err)
    })
}, err => {
    console.log(err)
})

Questions:

1.Whether this is able to understand quickly
2.Whether this code is able to debug
3.Whehter this code is scalable?
4.whether this code is maintaiable?


  "No" : This is what we call as "Callback hell".

fs.readdir(source, function (err, files) {
  if (err) {
    console.log('Error finding files: ' + err)
  } else {
    files.forEach(function (filename, fileIndex) {
      console.log(filename)
      gm(source + filename).size(function (err, values) {
        if (err) {
          console.log('Error identifying file size: ' + err)
        } else {
          console.log(filename + ' : ' + values)
          aspect = (values.width / values.height)
          widths.forEach(function (width, widthIndex) {
            height = Math.round(width / aspect)
            console.log('resizing ' + filename + 'to ' + height + 'x' + height)
            this.resize(width, height).write(dest + 'w' + width + '_' + filename, function(err) {
              if (err) console.log('Error writing file: ' + err)
            })
          }.bind(this))
        }
      })
    })
  }
})


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
///////////////////////////////////////////////////////////////////////////////////////////

How to write better callback programming /async/non blocking ? or How to avoid callback hell?


In 2005, JQUERY team started with working complex callback patterns, they found callback hell problem.

They proposed a  Design pattern to write better callback programming(Async) programming.

  "Promise".

Promise is design pattern which hides complexity of callback patterns


SInce Promise is design pattern, many people have implemented Promise design pattern.

1.JQuery -first promise implementation
2.many libs and frameworks

2012 E6 Commit introduced promise design pattern  as  "Promise" Object  in javascript.

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
Promise Object:
..............
 
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&


Promises and non blocking,async and callback hell issues:
.........................................................

features of Promise Object:

1.Promise by deafult is Async. Which implements timer api with 0 ms .

Promise can be used with any async callback based  implementations.

Objective:

 To remove callbacks in async/non blocking code. write cleaner async programming.
 To remove complex callback chaining code.


Promise Implemenation:

1. Create Promise Object from Promise contructor
2. Create Promise object from factory apis 

Promise object methods:
1.then - success
2.catch - errors
3.finally - clean up
factory api to create Promise object
4.resolve
5.reject
.......................................
6.all
7.race

Lets code using Promise

Promise Object creations:

1.factory apis.
 resolve
 reject
 both


//promise object
//using factory methods
//promise replaces callback function passing


// function getSuccess(callback) {
//     //factory
//     setTimeout(callback, 0, "Success")
// }

// getSuccess(data => console.log(data));

function getSuccess() {
    //factory
    return Promise.resolve('Success')
}
function getError() {
    //factory
    return Promise.reject('something went wrong!!')
}

function validate() {
    let userName = "admin";
    let password = "admin";
    if (userName === 'admin' && password === 'admin') {
        return Promise.resolve('Login success')
    }
    return Promise.reject('Login failed')
}


//
// let result = getSuccess();
// console.log(result)
// result.then(data=>console.log(data))
console.log('start')
getSuccess()
    .then(data => console.log(data));

getError()
    .catch(err => console.log(err));

validate()
    .then(status => console.log(status))
    .catch(err => console.log(err))
    .finally(() => console.log('done'))
console.log('end')
///////////////////////////////////////////////////////////////////////////////////
//Promise constructors pattern is used to abstract existing callback based programming.

function delay(callback) {
    //i want to return some data using timer after 5000ms
    setTimeout(callback, 5000, "Hello")
}
function delayWithPromise() {
    return new Promise((resovle, reject) => {
        setTimeout(resovle, 5000, "Hello")
    });
}

delay(data => console.log(data))

delayWithPromise()
    .then(data => console.log(data))
    .catch(err => console.log(err))
    .finally(() => console.log('done'));

//////////////////////////////////////////////////////////////////////////////////////////////

callback hell using promise 

//callback nesting/compostion

const getUser = () => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //  user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
};
//Login function is called with user as input.
const login = user => {
    let status = "Login success"
    let err = "Login failed"
    //bizlogic
    if (user.name === 'admin') {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, status)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
}

const showpage = status => {
    //biz logic
    if (status === 'Login success') {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, { message: 'You are admin' });
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, { message: 'You are guest' });
        });
    }

}

getUser()
    .then(user => {
        console.log('Get user is called', user)
        login(user)
            .then(status => {
                console.log('login is called', status);
                showpage(status)
                    .then(pageres => {
                        console.log('show page is called', pageres)
                    })
                    .catch(pageerror => console.log(pageerror));
            })
            .catch(err => {
                console.log(err)
            });
    })
    .catch(err => {
        console.log(err)
    });

//simplified way

getUser()
    .then(user => {
        console.log('Get user is called', user)
        return login(user)
    })
    .then(status => {
        console.log('login is called', status);
        return showpage(status);
    })
    .then(page => {
        console.log('show page is called', page)
    })
    .catch(err => {
        console.log(err);
    });

getUser()
    .then(user => login(user))
    .then(status => showpage(status))
    .then(page => console.log('show page is called', page))
    .catch(err => {
        console.log(err);
    });


// getUser(user => {
//     console.log('get User is called')
//     login(user, status => {
//         console.log('login is called')
//         showpage(status, who => {
//             console.log('show page is called')
//             console.log(who)
//         }, error => {
//             console.log(error)
//         })
//     }, err => {
//         console.log(err)
//     })
// }, err => {
//     console.log(err)
// })


The above code has solved callback hell issues, but still has some complixty, this 
is called "Promise hell".

How to avoid promise hell?


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

async and await ; es 7 keywords


Promise Hell: Promise has limitions;
......................

1.Promise is still  complex when you start scalling complex async operations.

2.Which is not readable ,which uses lot of then, catch blocks

In order to write even simple complex async work flows ES 7 introduced
a concept called "async await" keywords


 It is simplest pattern of Promises.
 It is promise driven only.

         "Sync style of Async Code" 

async key must be used with function declaration.
await is used to pause async calls


async ;

-used in front of function declaration ; those functions are called async function.

async is keyword must be used infront of function- async functions


async function returns Promise Object ---promise.resolve


async function getValue() {
    return 100;  // return Promise.resolve(100)
}
async function getSomething() {
    return Promise.resolve('something')
}

function getUser() {
    return Promise.resolve({ id: 1, name: 'admin' })
}

console.log(getValue());
getValue()
    .then(data => console.log(data));

getSomething()
    .then(data => console.log(data));
//how to read data from promise

//async....await

async function init() {
    const user = await getUser();
    console.log(user);
}
init();



///////////////

const getUser = () => {
    //biz logic
    let user = {
        id: 1,
        name: 'admin'
    };
    //user = null;
    let err = {
        message: 'User not found'
    }
    if (user) {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 1000, user)
        });
    } else {
        return new Promise((resolve, reject) => {
            setTimeout(reject, 1000, err)
        });
    }
};
//login; login function will be only if getUser returns user data.
const login = (user) => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (user.name === 'admin') {
            setTimeout(resolve, 1000, { message: 'Login Success' });
        } else {
            setTimeout(reject, 1000, { message: 'login failed' });
        }
    });

}

const showpage = (status) => {
    //biz logic
    return new Promise((resolve, reject) => {
        if (status.message === 'Login Success') {
            setTimeout(resolve, 1000, { message: 'You are admin' });
        } else {
            setTimeout(reject, 1000, { message: 'You are guest' });
        }
    });

};

async function init() {
    try {
        const user = await getUser();
        const status = await login(user);
        const page = await showpage(status);
        console.log(user,status,page)
    }
    catch (err) {
        console.log(err)
    }
}
init();
///////////////////////////////////////////////////////////////////////////////////////////


const USERS = require('../mockdata/users-mock')

class UserService {
    constructor() {

    }
    //sync
    findAll() {
        return USERS;
    }
    //async versions : callback version and promise 
    findAllCallback(callback) {
        setTimeout(callback, 5000, USERS);
    }
    findAllPromise() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, USERS);
        });
    }

}
module.exports = new UserService();



const { findAll, findAllCallback, findAllPromise } = require('./services/UserService');


async function main() {
    //sync
    // console.log(findAll());
    //console.log('start')
    //  findAllCallback(users=>console.log(users))
    // findAllPromise()
    //     .then(users => console.log(users))
    //     .catch(err => console.log(err))
    try {
        const users = await findAllPromise();
        console.log(users);
    }
    catch (err) {
        console.log(err)
    }
    // console.log('end')

}
main();
////////////////////////////////////////////////////////////////////////////////////////////

NODE APIS:
.........

Types of modules:

1.custom module
  built by us
2.built in modules
   provided by nodes
  
3.provided by third party/community
  libs,frameworks
 
1.node in built modules


1.os module
2.events module
3.file system module
4.path
5.http module

note: any module is distributed as javascript file

OS: Operating System
....................
The os module provides operating system-related utility methods and properties. 
It can be accessed using:
  os.js  ------> const ? =  require('os')

const { arch,hostname,cpus } = require('os');

console.log('Operating system infromation')
console.log(arch())
console.log(hostname())
console.log(cpus())




./ vs ''
.........

 require('./services/TODOService');
  ->here you can see ./
  ./ -current dir

 require('os'); => 
  -here no ./ 

Why?

Note : if you are java devp, you know the classpath , how it works?


require('os');

Node internally uses a search algorthim,node always looks the folder called
 "node_modules" in the current project, if not , then it searches, the node in built 
installtion folder---c:/pf/node/node_modules--if it finds it will pick up from there else it will throw error.

require('./services/TODOService');
   it will lookup in the current dir or sub dirs only.

nternal/modules/cjs/loader.js:800
    throw err;
    ^

Error: Cannot find module 'osxx'
Require stack:
- C:\session\ibm\feb\nodems\mynodeapps\src\index.js
[90m    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:797:15)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:690:27)[39m
[90m    at Module.require (internal/modules/cjs/loader.js:852:19)[39m
[90m    at require (internal/modules/cjs/helpers.js:74:18)[39m
    at Object.<anonymous> (C:\session\ibm\feb\nodems\mynodeapps\src\index.js:1:32)
[90m    at Module._compile (internal/modules/cjs/loader.js:959:30)[39m
[90m    at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10)[39m
[90m    at Module.load (internal/modules/cjs/loader.js:815:32)[39m
[90m    at Function.Module._load (internal/modules/cjs/loader.js:727:14)[39m
[90m    at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10)[39m {
  code: [32m'MODULE_NOT_FOUND'[39m,
  requireStack: [ [32m'C:\\session\\ibm\\feb\\nodems\\mynodeapps\\src\\index.js'[39m ]
}

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Event Emitter module;

how to build application event driven programming.

Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain kinds of objects (called "emitters") emit named events that cause Function objects ("listeners") to be called.
const EventEmitter = require('events');

const eventEmiter = new EventEmitter();

//Pub - sub

//register event :Listener
eventEmiter.on('hello', (data) => {
    console.log(data);
});

//Publisher : to emit event and send data

eventEmiter.emit('hello','Hello')

class OrderService extends EventEmitter {
    constructor() {
        super();
        //listener regeration ; event represents object having data .
        this.on('sales', event => {
            console.log(`Got ${event.orderId} ${event.qty} ${event.value}`)
        })
    }
    placeOrder(order) {
        //when ever place order is called, it can emit event
        setTimeout(() => {
          //async event driven programming
            this.emit('sales', order);
        }, 1000)
    }

}
//start
function startApp() {
    let orderService = new OrderService();
    //call biz api
    orderService.placeOrder({ orderId: 'OD001', qty: 100, value: 1000 })
}
startApp();

/////////////////////////////////////////////////////////////////////////////////////////////

IO
 -Fs
Network
 -web
 
npm
frameworks

/////////////////////////////////////////////////////////////////////////////////////////////

File system IO;

 - how to read file.
 - how to data into file.

node created async io,node also supports sync io like other languages.

Types io:
 -non-streaming io
 -streaming io /evented io.

Global variables in node:
.........................

__dirname
__filename



Non Streaming :

const fs = require('fs');
const path = require('path');

//const filePath = './src/assets/info.txt';
const filePath = path.join(__dirname,'assets/info.txt')
const options = {
    encoding: 'utf-8'
}
console.log('start')
fs.readFile(filePath, options, function (err, data) {
    if (err) throw err;
    console.log(data);
});
console.log('end')
////////////////////////////////////////////////////////////////////////////////////////////

Write file:
...........

const fs = require('fs');
const path = require('path');

//const filePath = './src/assets/info.txt';
const filePath = path.join(__dirname, 'assets/infocopy.txt')
const options = {
    encoding: 'utf-8'
}
const data = 'Hello,How are you';

fs.writeFile(filePath, data, options, err => {
  if (err) throw err;
  console.log(`data has been written into ${filePath}`)
})

Non streaming mode:

 The whole is file will be loaded into node process memory first, then file will be delivered
 This is not good , when we request files in network, if more files loaded into memory
 then node process memoery will grow, it may crash.

how to read and write files in non-streaming mode.
  -readFile and wirteFile
 

Streaming:

Streaming is nothing but flow of data(chunks).
Streaming allows move the data from one place to another place one by one.
Streaming apis are other wise called evented io. which is powered events.


Types of Streams:

1.Readable Stream : input
2.Writeable stream : output
3.Duplex stream : read + output

node has lot of built in stream apis

Built in readable Streams:

HTTP responses, on the client
HTTP requests, on the server
fs read streams
zlib streams
crypto streams
TCP sockets
child process stdout and stderr
process.stdin


Writable Streams:

HTTP requests, on the client
HTTP responses, on the server
fs write streams
zlib streams
crypto streams
TCP sockets
child process stdin
process.stdout, process.stderr


All streaming apis are powered with events
node io streams has built in events.
events are emitted by node.
Our programs are listeners

common events in all io

data event:
 which is emitted by node, for each chunk.

close event:
 The 'close' event is emitted when the stream and any of its underlying resources (a file descriptor, for example) have been closed.

end event:
 The 'end' event is emitted when there is no more data to be consumed from the stream.

Event: 'error'
 The 'error' event may be emitted by a Readable implementation at any time
Typically, this may occur if the underlying stream is unable to generate data due to an underlying internal failure, or when a stream implementation attempts to push an invalid chunk of data.


const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/info.txt');
const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(fileName, config);

//data event is emitted by os for each chunk of data
let data = ''
inputStream.on('data', chunk=> {
    log(`Received ${chunk.length} bytes of data.`)
    data += chunk;
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
    log(data);
})

//error event: for error handling
inputStream.on('error', err => {
    log(`Some thing went wrong! ${err}`)
});

////////////////////////////////////////////////////////////////////////////////////////////
const fs = require('fs');
const path = require('path');

const fileName = path.join(__dirname, 'assets/grains.txt');

const config = {
    encoding: 'utf8',
    flag: 'w'
};
const outputStream = fs.createWriteStream(fileName, config);

const grains = ['wheat', 'rice', 'oats'];

grains.forEach(grain => {
    outputStream.write(grain + " ");
    console.log("Wrote: %s", grain);
});

outputStream.close();

outputStream.on('close', function () {
    console.log('file has been closed ')
})
//////////////////////////////////////////////////////////////////////////////////////////////

Bigfile creation:
const fs = require('fs');
const path = require('path')

const filePath = path.join(__dirname, "assets/big.file")
const file = fs.createWriteStream(filePath);

for (let i = 0; i <= 1e6; i++) {
    file.write('Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n');
}

file.end();
////////////////////////////////////////////////////////////////////////////////////////////

Big file read:

const fs = require('fs');
const path = require('path');
const { log } = console;

const fileName = path.join(__dirname, 'assets/big.file');
const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(fileName, config);

//read data ; you need to register listeners for io.

//data event is emitted by os for each chunk of data
inputStream.on('data', function (chunk) {
    log(`Received ${chunk.length} bytes of data.`)
})

//end event is called , no more chunk of data is availble.
inputStream.on('end', () => {
    log('There will be no more data to read!');
})

//error event: for error handling
inputStream.on('error', (err) => {
    log(`Some thing went wrong! ${err}`)
});
////////////////////////////////////////////////////////////////////////////////////////////////

Read + Write:
.............
const fs = require('fs');
const path = require('path');

//read
const inputfileName = path.join(__dirname, 'assets/big.file');
//write
const outputFileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

const inputStream = fs.createReadStream(inputfileName, config);
const outputStream = fs.createWriteStream(outputFileName, config);

//Register data event.
inputStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    outputStream.write(chunk);
});


//end event
inputStream.on('end', function () {
    console.log('There will be no more data to read!');
    outputStream.close();
})

//error event: for error handling
inputStream.on('error', function (err) {
    console.log(`Some thing went wrong! ${err}`)
});

outputStream.on('close', function () {
    console.log(`File write operation is completed`);
});

BackPressure:
.............
Problems when you do read and write together

1. In general read operation is faster than write operation


Back Pressure means inputstream is fast, outputstream slow, then data will be
lost.

How to handle back pressure?

 apis  : pause,resume,drain event


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'assets/big.file');
const outputfileName = path.join(__dirname, 'assets/bigcopy.file');

const config = {
    encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);



readerStream.on('data', function (chunk) {
    console.log(`Received ${chunk.length} bytes of data.`);
    let buffer_good = writeStr.write(chunk);
    if (!buffer_good) readerStream.pause();
});
writeStr.on('drain', function () {
    console.log('buffer drained!');
    readerStream.resume();
});
readerStream.on('end', function () {
    //console.log(data);
});

readerStream.on('error', function (err) {
    console.log(err.stack);
});

///////////////////////////////////////////////////////////////////////////////////////////////////

pipe method is simplest method for implementing back pressure:


const fs = require('fs');
const path = require('path');

const inputfileName = path.join(__dirname, 'big.file');
const outputfileName = path.join(__dirname, 'big_copy.file');

const config = {
      encoding: 'UTF-8'
}

//Back pressure handling
const readerStream = fs.createReadStream(inputfileName, config);
const writeStr = fs.createWriteStream(outputfileName, config);

//backPressure streams
//pipe method is simplest method which wraps resume,pasuse,drain 
readerStream.pipe(writeStr);

&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Web programming : network Programming:
......................................

Nonblocking web servers and apps.

HTTP:

Node invented for building network io applications.

Network implementation in non blocking:

HTTP module is used to build http server,app, deployment


HTTP modules objects:


1.Server
  Server object is used to implement http servers/web containers
2.ServerResponse
  Object is used to send data 
3.ClientRequest
   Request object is used to handle http client requests
4.IncommingMessage
   Represents message payloads.


Note: all http implemnetation is streaming powered by default.


Steps:

1.create Server.
2.request-response handling
3.starting server

Node handles every client request by a single thread-Event loop thread


const http = require('http');

//create server

const server =  http.createServer((req,res)=>{
    res.write('Hello');
    res.end();
});
//start the server 
server.listen(3000,()=>{
    console.log('Server is Ready!');
})

//////////////////////////////////////////////////////////////////////////////////////////


send json data:

const http = require('http');
const USERS =require('./mock-data/users-mock')


//create server

const server =  http.createServer((req,res)=>{
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    const users = JSON.stringify(USERS);
    res.write(users);
    res.end();
});
//start the server 
server.listen(3000,()=>{
    console.log('Server is Ready!');
})
///////////////////////////////////////////////////////////////////////////////////////////

client -------Web layer -----Service layer-------Mock data.

src/services/userservice.js


const http = require('http');
const { findAll } = require('./services/userservice')

//create server

const server = http.createServer(async (req, res) => {
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    // findAll().then((users)=>{
    //     res.write(users);
    //     res.end();
    // })
    try {
        const users = await findAll();
        res.write(users);
        res.end();
    }
    catch(err){
        res.write({message:'something went wrong'})
        res.end();
    }

});
//start the server 
server.listen(3000, () => {
    console.log('Server is Ready!');
})

const http = require('http');
const { findAll } = require('./services/userservice')

//create server

const server = http.createServer(async (req, res) => {
    //RESPONSE Header to tell what type of data.
    res.writeHead(200, {
        'Content-Type': 'application/json'
    })
    //convert array into json string
    // findAll().then((users)=>{
    //     res.write(users);
    //     res.end();
    // })
    try {
        const users = await findAll();
        res.write(users);
        res.end();
    }
    catch(err){
        res.write({message:'something went wrong'})
        res.end();
    }

});
//start the server 
server.listen(3000, () => {
    console.log('Server is Ready!');
})
////////////////////////////////////////////////////////////////////////////////////////////

Client INput:
............


const http = require('http');
const { log } = console;

const server = http.createServer((req, res) => {

    let body='';
    req.on('data', (chunk) => {
        body += chunk;
        log(body);
    });

    res.on('close', () => {
        log('response close event is called')
    });
    res.on('finish', () => {
        log('response has been sent /committed')
    });
    res.end("Hello,Node")
});

server.listen(3000, () => {
    console.log(`Http Server listens @ ${3000}`)
});
////////////////////////////////////////////////////////////////////////////////////////////

Can you build realtime web applications using http module alone?

Yes,but it takes lot of code(boiler platecode).

We need abstractions -  libs,frameworks......

who offers frameworks and libs? from where we can get it?

Third parties,communities,companies(google,ms,yahoo,facebook....)

From centeral repo server called "npm registry"

How to bring thrid party libs/frameworks/modules into our project?

Tool : NPM - Node package Manager:
.................................
npm is tool is used to distribute node modules to others
and you can get node modules from other others.

npm tool is distributed along with node installation

npm uses public repository server called npmjs.com npmjs.org

tools and libs,frameworks all are distributed as node modules into repository.

Java script application :

Javascript Project Structure:(server side/ client side)
.........................................................


The project must have two things

1.package.json file :
   meta file which describes the project information
2.node_modules folder
   which contains libs/frameworks/tools code.

create package.json file

>npm init

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC"
}

npm is used

to install,uninstall,publish node modules from node repo / into node repo.

if you install third party modules , into your project, node distributes npm tool ,using this you can install,uninstall,upgrade node modules.


installing module:

>npm install  moduleName  --options
>npm i moduleName --options


>npm install module 
  here no option is told, means default is --save

>npm i module

options:
 --save ; 
 --save-dev
 -g

//////////////////////////////////////////////////////////////////////////////////////////////////////
App development ; three stage

1.dev
2.testing
3.production.

if you install any packages/dependencies, you can tell that is it for production and developemnt, only devel/testing

if you are installing any node module, you can tell, do you want to use only for development
or development + production.

Unit testing libs : Junit.jar===>java

 --save = >    development + production
 --save-dev => only for development

Which code need not be used for production:

1.All testing related  libs/frameworks - unit,e2s
2.Tools like compilers,frameworks related code.

Who will separate out this depedency(lib) for production/dev

 Build tools -  webpack.
 webpack will scan package.json---extracting prod depedencies

////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////

 --save => dev + production
 default =>dev + production

 --save-dev  -->only dev 

//////////////////////////////////////////////////////////////////////////////////////////////////////

Eg;
npm i --save lodash

package.json
{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  }
}
node_modules

const array = require('lodash/array')

const list = [1, 2, 3];

array.fill(list, 'a');
console.log(list);


/////////////////////////////////////////////////////////////////////////////////////////////////////

Development only module: unit testing module

->chai.js

npm install chai --save-dev


//////////////////////////////////////////////////////////////////////////////////////////////

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  },
  "devDependencies": {
    "chai": "^4.2.0"
  }
}

/////////////////////////////////////////////////////////////////////////////////////////////

How to uninstall node modules?
//////////////////////////////////////////////////////////////////////////////////////////////////////

How to remove unwanted node modules?

npm uinstall jquery --save
////////////////////////////////////////////////////////////////////////////////////////////////////////

Global Modules:
...............

-g  --global:
............

global modules are modules which are not installed inside project floder.

What is use of global modules?

->tools
   like compilers,build system,webserver,testing frameworks.


C:\Users\sasub\AppData\Roaming\npm -- here only all global modules will be installed.


Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha

Demo:
....

npm install module-name(tool) -g

mocha : unit testing framwork, is used to run java script unit testing on node and browser.

npm install --global mocha
npm install -g mocha
...........................................&&&&&&&&&&&&&&&&&&&&********************************************


&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Automation:


We can automate js applications.

write all auotomation steps inside scripts

"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  }

key: value

key is called command-script command
value is task to be executed. ; task could be any thing.

command can be built in or custom commands

npm provides lot of built in commands

start,test,postinstall,preinstall..........


how to run node apps using npm scripts.

node filename.js --direct use

via script
how to run script

>npm commandname ---incase of built in command
>npm start

>npm run commandname - custom commands
>npm run subu

  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start" : "node src/app.js",
    "subu"  :"node src/app.js"
  },

npm test
npm start
npm run subu
..............................................................................................
                      Global Modules and Its problems, How to solve them
/////////////////////////////////////////////////////////////////////////////////////////////

Objective:
 For brining tools

tools
  -compilers
  -frameworks
  -webservers
  -build tools

npm install webpack -g

Problems with Global Modules:
..............................

1.version and compablity issue for new projects

solution: 
 install those golbal tools as local dev modules



solution: 
 install those golbal tools as local dev modules

g vs --save-dev:

global dependencies not good for multiple sharing projects
install tools as project specific. --save-dev

{
  "name": "mynodeapps",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "start": "node src/app.js",
    "subu": "node src/app.js"
  },
  "author": "Subramanian Murugan",
  "license": "ISC",
  "dependencies": {
    "lodash": "^4.17.20"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^8.2.1"
  }
}
//////////////////////////////////////////////////////////////////////////////////////////////
                              How to Build Restfull Web Apps                                     
Framework: Express.js

What is express?
Express Fast, unopinionated, minimalist web framework for Node.js

express is built on top of http core module.

What express provides?

-To build rest api facility fast using routers
->provides of lot of middlewares(utility libs) for database access,secuity,template....


How to start express project

-from begining

-using tool express-generator
  used to create quick web apps...
   

 npm install express --save


Express Key concepts: in express every thing object

Objects in express

1.Application
  We call Container object which other objects
  entry and exit of an application
  application is created by calling function

2.Request

4.Response

5.Router

1.Application object roll:

Routing HTTP requests; see for example, app.METHOD and app.param.
Configuring middleware; see app.route.
Rendering HTML views; see app.render.
Registering a template engine; see app.engine.

const express  = require('express');

//create application object
const app =  express();

//create End Points

app.get('/',(req,res)=>{
    res.end('Home')
});
app.get('/api/message/hai',(req,res)=>{
    res.end('hai')
});
app.get('/api/message/hello',(req,res)=>{
    res.end('hello')
});
app.get('/api/message/greet',(req,res)=>{
    res.end('greet')
});
app.post('/api/message/save',(req,res)=>{
    res.end('save')
})
app.put('/api/message/update',(req,res)=>{
    res.end('put')
})
app.delete('/api/message/delete',(req,res)=>{
    res.end('delete')
})

//start server

app.listen(3000,()=>console.log('express server is running!!!'))
/////////////////////////////////////////////////////////////////////////////////////////////

Modualirty:
...........


const express = require('express');
const { findAll } = require('../services/userservice');

//create router object
const userRouter = express.Router();

userRouter.get('/list', async (req, res) => {
    const users = await findAll();
    res.json(users)
});

module.exports = userRouter;


const express = require('express');
const { listTodos } = require('../services/todoservice');

//create router object
const todoRouter = express.Router();

todoRouter.get('/list', async (req, res) => {
    const todos = await listTodos();
    res.json(todos)
});

module.exports = todoRouter;


const TODOS = require('../mock-data/todos');

class TodoService {
    constructor() {
    }
    listTodos() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, TODOS);
        });
    }
 
}

module.exports = new TodoService();



const USERS = require('../mock-data/users-mock');

class UserService {
    constructor() {
    }
    findAll() {
        return new Promise((resolve, reject) => {
            setTimeout(resolve, 5000, USERS);
        });
    }
 
}

module.exports = new UserService();




const express = require('express');
const userRouter = require('./routers/userrouter');
const todoRouter = require('./routers/todorouter')

const app = express();

//Linking UserRouter with main app
app.use('/api/users',userRouter);
app.use('/api/todos',todoRouter);


app.listen(3000, () => console.log('Express server is running!!!'))

////////////////////////////////////////////////////////////////////////////////////////////

Middlewares:

 - plugins , can  be plugged


types of middlewares

1.built in middlewares
2.third party middleware
3.custom middleares.

Use case :
 How to read JSON input. Express server need to read json which was submitted by endusers

User will submit as json --- express need to convert into javascript object.

any middleware is distributed as node modules only, so you need to install



Steps for any middleware integration:
......................................

1.npm install body-parser

2.Register middleware - in the main app
const bodyParser = require('body-parser')
// parse application/json
app.use(bodyParser.json())

3.use the middleware;
////////////////////////////////////////////////////////////////////////////////////////////

Express application generator
.............................




/////////////////////////////////////////////////////////////////////////////////////////////

                                 Distribted Application development
                                       (Micro services)


Framework:Moleculr.js
/////////////////////////////////////////&&&&&&&&&&&&&&&&&&&&&///////////////////////////////
































